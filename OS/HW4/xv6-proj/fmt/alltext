0100 typedef unsigned int   uint;
0101 typedef unsigned short ushort;
0102 typedef unsigned char  uchar;
0103 typedef uint pde_t;
0104 
0105 
0106 
0107 
0108 
0109 
0110 
0111 
0112 
0113 
0114 
0115 
0116 
0117 
0118 
0119 
0120 
0121 
0122 
0123 
0124 
0125 
0126 
0127 
0128 
0129 
0130 
0131 
0132 
0133 
0134 
0135 
0136 
0137 
0138 
0139 
0140 
0141 
0142 
0143 
0144 
0145 
0146 
0147 
0148 
0149 
0150 #define NPROC        64  
0151 #define KSTACKSIZE 4096  
0152 #define NCPU          8  
0153 #define NOFILE       16  
0154 #define NFILE       100  
0155 #define NINODE       50  
0156 #define NDEV         10  
0157 #define ROOTDEV       1  
0158 #define MAXARG       32  
0159 #define MAXOPBLOCKS  10  
0160 #define LOGSIZE      (MAXOPBLOCKS*3)  
0161 #define NBUF         (MAXOPBLOCKS*3)  
0162 #define FSSIZE       1000  
0163 
0164 
0165 
0166 
0167 
0168 
0169 
0170 
0171 
0172 
0173 
0174 
0175 
0176 
0177 
0178 
0179 
0180 
0181 
0182 
0183 
0184 
0185 
0186 
0187 
0188 
0189 
0190 
0191 
0192 
0193 
0194 
0195 
0196 
0197 
0198 
0199 
0200 
0201 
0202 #define EXTMEM  0x100000            
0203 #define PHYSTOP 0xE000000           
0204 #define DEVSPACE 0xFE000000         
0205 
0206 
0207 #define KERNBASE 0x80000000         
0208 #define KERNLINK (KERNBASE+EXTMEM)  
0209 
0210 #define V2P(a) (((uint) (a)) - KERNBASE)
0211 #define P2V(a) (((void *) (a)) + KERNBASE)
0212 
0213 #define V2P_WO(x) ((x) - KERNBASE)    
0214 #define P2V_WO(x) ((x) + KERNBASE)    
0215 
0216 
0217 
0218 
0219 
0220 
0221 
0222 
0223 
0224 
0225 
0226 
0227 
0228 
0229 
0230 
0231 
0232 
0233 
0234 
0235 
0236 
0237 
0238 
0239 
0240 
0241 
0242 
0243 
0244 
0245 
0246 
0247 
0248 
0249 
0250 struct buf;
0251 struct context;
0252 struct file;
0253 struct inode;
0254 struct pipe;
0255 struct proc;
0256 struct rtcdate;
0257 struct spinlock;
0258 struct sleeplock;
0259 struct stat;
0260 struct superblock;
0261 typedef unsigned long int thread_t;
0262 
0263 
0264 void            binit(void);
0265 struct buf*     bread(uint, uint);
0266 void            brelse(struct buf*);
0267 void            bwrite(struct buf*);
0268 
0269 
0270 void            consoleinit(void);
0271 void            cprintf(char*, ...);
0272 void            consoleintr(int(*)(void));
0273 void            panic(char*) __attribute__((noreturn));
0274 
0275 
0276 int             exec(char*, char**);
0277 
0278 
0279 struct file*    filealloc(void);
0280 void            fileclose(struct file*);
0281 struct file*    filedup(struct file*);
0282 void            fileinit(void);
0283 int             fileread(struct file*, char*, int n);
0284 int             filestat(struct file*, struct stat*);
0285 int             filewrite(struct file*, char*, int n);
0286 
0287 
0288 void            readsb(int dev, struct superblock *sb);
0289 int             dirlink(struct inode*, char*, uint);
0290 struct inode*   dirlookup(struct inode*, char*, uint*);
0291 struct inode*   ialloc(uint, short);
0292 struct inode*   idup(struct inode*);
0293 void            iinit(int dev);
0294 void            ilock(struct inode*);
0295 void            iput(struct inode*);
0296 void            iunlock(struct inode*);
0297 void            iunlockput(struct inode*);
0298 void            iupdate(struct inode*);
0299 int             namecmp(const char*, const char*);
0300 struct inode*   namei(char*);
0301 struct inode*   nameiparent(char*, char*);
0302 int             readi(struct inode*, char*, uint, uint);
0303 void            stati(struct inode*, struct stat*);
0304 int             writei(struct inode*, char*, uint, uint);
0305 
0306 
0307 void            ideinit(void);
0308 void            ideintr(void);
0309 void            iderw(struct buf*);
0310 
0311 
0312 void            ioapicenable(int irq, int cpu);
0313 extern uchar    ioapicid;
0314 void            ioapicinit(void);
0315 
0316 
0317 char*           kalloc(void);
0318 void            kfree(char*);
0319 void            kinit1(void*, void*);
0320 void            kinit2(void*, void*);
0321 
0322 
0323 void            kbdintr(void);
0324 
0325 
0326 void            cmostime(struct rtcdate *r);
0327 int             cpunum(void);
0328 extern volatile uint*    lapic;
0329 void            lapiceoi(void);
0330 void            lapicinit(void);
0331 void            lapicstartap(uchar, uint);
0332 void            microdelay(int);
0333 
0334 
0335 void            initlog(int dev);
0336 void            log_write(struct buf*);
0337 void            begin_op();
0338 void            end_op();
0339 
0340 
0341 extern int      ismp;
0342 void            mpinit(void);
0343 
0344 
0345 void            picenable(int);
0346 void            picinit(void);
0347 
0348 
0349 
0350 
0351 int             pipealloc(struct file**, struct file**);
0352 void            pipeclose(struct pipe*, int);
0353 int             piperead(struct pipe*, char*, int);
0354 int             pipewrite(struct pipe*, char*, int);
0355 
0356 
0357 
0358 void            exit(void);
0359 int             fork(void);
0360 int             growproc(int);
0361 int             kill(int);
0362 void            pinit(void);
0363 void            procdump(void);
0364 void            scheduler(void) __attribute__((noreturn));
0365 void            sched(void);
0366 void            sleep(void*, struct spinlock*);
0367 void            userinit(void);
0368 int             wait(void);
0369 void            wakeup(void*);
0370 void            yield(void);
0371 void            findMinPassStride(void);
0372 void            printPtable(void);
0373 int             thread_create(thread_t *thread, void *(*start_routine)(void *), void*arg);
0374 void            thread_exit(void * retval) __attribute__ ((noreturn));
0375 int             thread_join(thread_t thread, void **retval);
0376 int             thread_clean(thread_t thread, void **retval);
0377 void		    clean(struct proc *target);
0378 int             thread_fork(void);
0379 void            share_stride_in_proc(struct proc* parent);
0380 
0381 void            swtch(struct context**, struct context*);
0382 
0383 
0384 void            acquire(struct spinlock*);
0385 void            getcallerpcs(void*, uint*);
0386 int             holding(struct spinlock*);
0387 void            initlock(struct spinlock*, char*);
0388 void            release(struct spinlock*);
0389 void            pushcli(void);
0390 void            popcli(void);
0391 
0392 
0393 void            acquiresleep(struct sleeplock*);
0394 void            releasesleep(struct sleeplock*);
0395 int             holdingsleep(struct sleeplock*);
0396 void            initsleeplock(struct sleeplock*, char*);
0397 
0398 
0399 
0400 
0401 int             memcmp(const void*, const void*, uint);
0402 void*           memmove(void*, const void*, uint);
0403 void*           memset(void*, int, uint);
0404 char*           safestrcpy(char*, const char*, int);
0405 int             strlen(const char*);
0406 int             strncmp(const char*, const char*, uint);
0407 char*           strncpy(char*, const char*, int);
0408 
0409 
0410 int             argint(int, int*);
0411 int             argptr(int, char**, int);
0412 int             argstr(int, char**);
0413 int             fetchint(uint, int*);
0414 int             fetchstr(uint, char**);
0415 void            syscall(void);
0416 
0417 
0418 void            timerinit(void);
0419 
0420 
0421 void            idtinit(void);
0422 extern uint     ticks;
0423 void            tvinit(void);
0424 extern struct spinlock tickslock;
0425 
0426 
0427 void            uartinit(void);
0428 void            uartintr(void);
0429 void            uartputc(int);
0430 
0431 
0432 void            seginit(void);
0433 void            kvmalloc(void);
0434 pde_t*          setupkvm(void);
0435 char*           uva2ka(pde_t*, char*);
0436 int             allocuvm(pde_t*, uint, uint);
0437 int             deallocuvm(pde_t*, uint, uint);
0438 void            freevm(pde_t*);
0439 void            inituvm(pde_t*, char*, uint);
0440 int             loaduvm(pde_t*, char*, struct inode*, uint, uint);
0441 pde_t*          copyuvm(pde_t*, uint);
0442 void            switchuvm(struct proc*);
0443 void            switchkvm(void);
0444 int             copyout(pde_t*, uint, void*, uint);
0445 void            clearpteu(pde_t *pgdir, char *uva);
0446 void            empty_stack_clean(struct proc *p);
0447 pde_t*          copyuvm_force(pde_t*, uint);
0448 
0449 
0450 
0451 int             my_syscall(char*);
0452 
0453 #define NELEM(x) (sizeof(x)/sizeof((x)[0]))
0454 
0455 
0456 
0457 
0458 
0459 
0460 
0461 
0462 
0463 
0464 
0465 
0466 
0467 
0468 
0469 
0470 
0471 
0472 
0473 
0474 
0475 
0476 
0477 
0478 
0479 
0480 
0481 
0482 
0483 
0484 
0485 
0486 
0487 
0488 
0489 
0490 
0491 
0492 
0493 
0494 
0495 
0496 
0497 
0498 
0499 
0500 
0501 
0502 static inline uchar
0503 inb(ushort port)
0504 {
0505   uchar data;
0506 
0507   asm volatile("in %1,%0" : "=a" (data) : "d" (port));
0508   return data;
0509 }
0510 
0511 static inline void
0512 insl(int port, void *addr, int cnt)
0513 {
0514   asm volatile("cld; rep insl" :
0515                "=D" (addr), "=c" (cnt) :
0516                "d" (port), "0" (addr), "1" (cnt) :
0517                "memory", "cc");
0518 }
0519 
0520 static inline void
0521 outb(ushort port, uchar data)
0522 {
0523   asm volatile("out %0,%1" : : "a" (data), "d" (port));
0524 }
0525 
0526 static inline void
0527 outw(ushort port, ushort data)
0528 {
0529   asm volatile("out %0,%1" : : "a" (data), "d" (port));
0530 }
0531 
0532 static inline void
0533 outsl(int port, const void *addr, int cnt)
0534 {
0535   asm volatile("cld; rep outsl" :
0536                "=S" (addr), "=c" (cnt) :
0537                "d" (port), "0" (addr), "1" (cnt) :
0538                "cc");
0539 }
0540 
0541 static inline void
0542 stosb(void *addr, int data, int cnt)
0543 {
0544   asm volatile("cld; rep stosb" :
0545                "=D" (addr), "=c" (cnt) :
0546                "0" (addr), "1" (cnt), "a" (data) :
0547                "memory", "cc");
0548 }
0549 
0550 static inline void
0551 stosl(void *addr, int data, int cnt)
0552 {
0553   asm volatile("cld; rep stosl" :
0554                "=D" (addr), "=c" (cnt) :
0555                "0" (addr), "1" (cnt), "a" (data) :
0556                "memory", "cc");
0557 }
0558 
0559 struct segdesc;
0560 
0561 static inline void
0562 lgdt(struct segdesc *p, int size)
0563 {
0564   volatile ushort pd[3];
0565 
0566   pd[0] = size-1;
0567   pd[1] = (uint)p;
0568   pd[2] = (uint)p >> 16;
0569 
0570   asm volatile("lgdt (%0)" : : "r" (pd));
0571 }
0572 
0573 struct gatedesc;
0574 
0575 static inline void
0576 lidt(struct gatedesc *p, int size)
0577 {
0578   volatile ushort pd[3];
0579 
0580   pd[0] = size-1;
0581   pd[1] = (uint)p;
0582   pd[2] = (uint)p >> 16;
0583 
0584   asm volatile("lidt (%0)" : : "r" (pd));
0585 }
0586 
0587 static inline void
0588 ltr(ushort sel)
0589 {
0590   asm volatile("ltr %0" : : "r" (sel));
0591 }
0592 
0593 static inline uint
0594 readeflags(void)
0595 {
0596   uint eflags;
0597   asm volatile("pushfl; popl %0" : "=r" (eflags));
0598   return eflags;
0599 }
0600 static inline void
0601 loadgs(ushort v)
0602 {
0603   asm volatile("movw %0, %%gs" : : "r" (v));
0604 }
0605 
0606 static inline void
0607 cli(void)
0608 {
0609   asm volatile("cli");
0610 }
0611 
0612 static inline void
0613 sti(void)
0614 {
0615   asm volatile("sti");
0616 }
0617 
0618 static inline uint
0619 xchg(volatile uint *addr, uint newval)
0620 {
0621   uint result;
0622 
0623   
0624   asm volatile("lock; xchgl %0, %1" :
0625                "+m" (*addr), "=a" (result) :
0626                "1" (newval) :
0627                "cc");
0628   return result;
0629 }
0630 
0631 static inline uint
0632 rcr2(void)
0633 {
0634   uint val;
0635   asm volatile("movl %%cr2,%0" : "=r" (val));
0636   return val;
0637 }
0638 
0639 static inline void
0640 lcr3(uint val)
0641 {
0642   asm volatile("movl %0,%%cr3" : : "r" (val));
0643 }
0644 
0645 
0646 
0647 
0648 
0649 
0650 
0651 
0652 struct trapframe {
0653   
0654   uint edi;
0655   uint esi;
0656   uint ebp;
0657   uint oesp;      
0658   uint ebx;
0659   uint edx;
0660   uint ecx;
0661   uint eax;
0662 
0663   
0664   ushort gs;
0665   ushort padding1;
0666   ushort fs;
0667   ushort padding2;
0668   ushort es;
0669   ushort padding3;
0670   ushort ds;
0671   ushort padding4;
0672   uint trapno;
0673 
0674   
0675   uint err;
0676   uint eip;
0677   ushort cs;
0678   ushort padding5;
0679   uint eflags;
0680 
0681   
0682   uint esp;
0683   ushort ss;
0684   ushort padding6;
0685 };
0686 
0687 
0688 
0689 
0690 
0691 
0692 
0693 
0694 
0695 
0696 
0697 
0698 
0699 
0700 
0701 
0702 
0703 
0704 #define SEG_NULLASM                                             \
0705         .word 0, 0;                                             \
0706         .byte 0, 0, 0, 0
0707 
0708 
0709 
0710 #define SEG_ASM(type,base,lim)                                  \
0711         .word (((lim) >> 12) & 0xffff), ((base) & 0xffff);      \
0712         .byte (((base) >> 16) & 0xff), (0x90 | (type)),         \
0713                 (0xC0 | (((lim) >> 28) & 0xf)), (((base) >> 24) & 0xff)
0714 
0715 #define STA_X     0x8       
0716 #define STA_E     0x4       
0717 #define STA_C     0x4       
0718 #define STA_W     0x2       
0719 #define STA_R     0x2       
0720 #define STA_A     0x1       
0721 
0722 
0723 
0724 
0725 
0726 
0727 
0728 
0729 
0730 
0731 
0732 
0733 
0734 
0735 
0736 
0737 
0738 
0739 
0740 
0741 
0742 
0743 
0744 
0745 
0746 
0747 
0748 
0749 
0750 
0751 
0752 
0753 
0754 #define FL_CF           0x00000001      
0755 #define FL_PF           0x00000004      
0756 #define FL_AF           0x00000010      
0757 #define FL_ZF           0x00000040      
0758 #define FL_SF           0x00000080      
0759 #define FL_TF           0x00000100      
0760 #define FL_IF           0x00000200      
0761 #define FL_DF           0x00000400      
0762 #define FL_OF           0x00000800      
0763 #define FL_IOPL_MASK    0x00003000      
0764 #define FL_IOPL_0       0x00000000      
0765 #define FL_IOPL_1       0x00001000      
0766 #define FL_IOPL_2       0x00002000      
0767 #define FL_IOPL_3       0x00003000      
0768 #define FL_NT           0x00004000      
0769 #define FL_RF           0x00010000      
0770 #define FL_VM           0x00020000      
0771 #define FL_AC           0x00040000      
0772 #define FL_VIF          0x00080000      
0773 #define FL_VIP          0x00100000      
0774 #define FL_ID           0x00200000      
0775 
0776 
0777 #define CR0_PE          0x00000001      
0778 #define CR0_MP          0x00000002      
0779 #define CR0_EM          0x00000004      
0780 #define CR0_TS          0x00000008      
0781 #define CR0_ET          0x00000010      
0782 #define CR0_NE          0x00000020      
0783 #define CR0_WP          0x00010000      
0784 #define CR0_AM          0x00040000      
0785 #define CR0_NW          0x20000000      
0786 #define CR0_CD          0x40000000      
0787 #define CR0_PG          0x80000000      
0788 
0789 #define CR4_PSE         0x00000010      
0790 
0791 
0792 #define SEG_KCODE 1  
0793 #define SEG_KDATA 2  
0794 #define SEG_KCPU  3  
0795 #define SEG_UCODE 4  
0796 #define SEG_UDATA 5  
0797 #define SEG_TSS   6  
0798 
0799 
0800 
0801 #define NSEGS     7
0802 
0803 
0804 
0805 
0806 
0807 
0808 
0809 
0810 
0811 
0812 
0813 
0814 
0815 
0816 
0817 
0818 
0819 
0820 
0821 
0822 
0823 
0824 
0825 
0826 
0827 
0828 
0829 
0830 
0831 
0832 
0833 
0834 
0835 
0836 
0837 
0838 
0839 
0840 
0841 
0842 
0843 
0844 
0845 
0846 
0847 
0848 
0849 
0850 #ifndef __ASSEMBLER__
0851 
0852 struct segdesc {
0853   uint lim_15_0 : 16;  
0854   uint base_15_0 : 16; 
0855   uint base_23_16 : 8; 
0856   uint type : 4;       
0857   uint s : 1;          
0858   uint dpl : 2;        
0859   uint p : 1;          
0860   uint lim_19_16 : 4;  
0861   uint avl : 1;        
0862   uint rsv1 : 1;       
0863   uint db : 1;         
0864   uint g : 1;          
0865   uint base_31_24 : 8; 
0866 };
0867 
0868 
0869 #define SEG(type, base, lim, dpl) (struct segdesc)    \
0870 { ((lim) >> 12) & 0xffff, (uint)(base) & 0xffff,      \
0871   ((uint)(base) >> 16) & 0xff, type, 1, dpl, 1,       \
0872   (uint)(lim) >> 28, 0, 0, 1, 1, (uint)(base) >> 24 }
0873 #define SEG16(type, base, lim, dpl) (struct segdesc)  \
0874 { (lim) & 0xffff, (uint)(base) & 0xffff,              \
0875   ((uint)(base) >> 16) & 0xff, type, 1, dpl, 1,       \
0876   (uint)(lim) >> 16, 0, 0, 1, 0, (uint)(base) >> 24 }
0877 #endif
0878 
0879 #define DPL_USER    0x3     
0880 
0881 
0882 #define STA_X       0x8     
0883 #define STA_E       0x4     
0884 #define STA_C       0x4     
0885 #define STA_W       0x2     
0886 #define STA_R       0x2     
0887 #define STA_A       0x1     
0888 
0889 
0890 #define STS_T16A    0x1     
0891 #define STS_LDT     0x2     
0892 #define STS_T16B    0x3     
0893 #define STS_CG16    0x4     
0894 #define STS_TG      0x5     
0895 #define STS_IG16    0x6     
0896 #define STS_TG16    0x7     
0897 #define STS_T32A    0x9     
0898 #define STS_T32B    0xB     
0899 #define STS_CG32    0xC     
0900 #define STS_IG32    0xE     
0901 #define STS_TG32    0xF     
0902 
0903 
0904 
0905 
0906 
0907 
0908 
0909 
0910 
0911 
0912 #define PDX(va)         (((uint)(va) >> PDXSHIFT) & 0x3FF)
0913 
0914 
0915 #define PTX(va)         (((uint)(va) >> PTXSHIFT) & 0x3FF)
0916 
0917 
0918 #define PGADDR(d, t, o) ((uint)((d) << PDXSHIFT | (t) << PTXSHIFT | (o)))
0919 
0920 
0921 #define NPDENTRIES      1024    
0922 #define NPTENTRIES      1024    
0923 #define PGSIZE          4096    
0924 
0925 #define PGSHIFT         12      
0926 #define PTXSHIFT        12      
0927 #define PDXSHIFT        22      
0928 
0929 #define PGROUNDUP(sz)  (((sz)+PGSIZE-1) & ~(PGSIZE-1))
0930 #define PGROUNDDOWN(a) (((a)) & ~(PGSIZE-1))
0931 
0932 
0933 #define PTE_P           0x001   
0934 #define PTE_W           0x002   
0935 #define PTE_U           0x004   
0936 #define PTE_PWT         0x008   
0937 #define PTE_PCD         0x010   
0938 #define PTE_A           0x020   
0939 #define PTE_D           0x040   
0940 #define PTE_PS          0x080   
0941 #define PTE_MBZ         0x180   
0942 
0943 
0944 #define PTE_ADDR(pte)   ((uint)(pte) & ~0xFFF)
0945 #define PTE_FLAGS(pte)  ((uint)(pte) &  0xFFF)
0946 
0947 #ifndef __ASSEMBLER__
0948 typedef uint pte_t;
0949 
0950 
0951 struct taskstate {
0952   uint link;         
0953   uint esp0;         
0954   ushort ss0;        
0955   ushort padding1;
0956   uint *esp1;
0957   ushort ss1;
0958   ushort padding2;
0959   uint *esp2;
0960   ushort ss2;
0961   ushort padding3;
0962   void *cr3;         
0963   uint *eip;         
0964   uint eflags;
0965   uint eax;          
0966   uint ecx;
0967   uint edx;
0968   uint ebx;
0969   uint *esp;
0970   uint *ebp;
0971   uint esi;
0972   uint edi;
0973   ushort es;         
0974   ushort padding4;
0975   ushort cs;
0976   ushort padding5;
0977   ushort ss;
0978   ushort padding6;
0979   ushort ds;
0980   ushort padding7;
0981   ushort fs;
0982   ushort padding8;
0983   ushort gs;
0984   ushort padding9;
0985   ushort ldt;
0986   ushort padding10;
0987   ushort t;          
0988   ushort iomb;       
0989 };
0990 
0991 
0992 
0993 
0994 
0995 
0996 
0997 
0998 
0999 
1000 
1001 struct gatedesc {
1002   uint off_15_0 : 16;   
1003   uint cs : 16;         
1004   uint args : 5;        
1005   uint rsv1 : 3;        
1006   uint type : 4;        
1007   uint s : 1;           
1008   uint dpl : 2;         
1009   uint p : 1;           
1010   uint off_31_16 : 16;  
1011 };
1012 
1013 
1014 
1015 
1016 
1017 
1018 
1019 
1020 
1021 #define SETGATE(gate, istrap, sel, off, d)                \
1022 {                                                         \
1023   (gate).off_15_0 = (uint)(off) & 0xffff;                \
1024   (gate).cs = (sel);                                      \
1025   (gate).args = 0;                                        \
1026   (gate).rsv1 = 0;                                        \
1027   (gate).type = (istrap) ? STS_TG32 : STS_IG32;           \
1028   (gate).s = 0;                                           \
1029   (gate).dpl = (d);                                       \
1030   (gate).p = 1;                                           \
1031   (gate).off_31_16 = (uint)(off) >> 16;                  \
1032 }
1033 
1034 #endif
1035 
1036 
1037 
1038 
1039 
1040 
1041 
1042 
1043 
1044 
1045 
1046 
1047 
1048 
1049 
1050 
1051 
1052 #define ELF_MAGIC 0x464C457FU  
1053 
1054 
1055 struct elfhdr {
1056   uint magic;  
1057   uchar elf[12];
1058   ushort type;
1059   ushort machine;
1060   uint version;
1061   uint entry;
1062   uint phoff;
1063   uint shoff;
1064   uint flags;
1065   ushort ehsize;
1066   ushort phentsize;
1067   ushort phnum;
1068   ushort shentsize;
1069   ushort shnum;
1070   ushort shstrndx;
1071 };
1072 
1073 
1074 struct proghdr {
1075   uint type;
1076   uint off;
1077   uint vaddr;
1078   uint paddr;
1079   uint filesz;
1080   uint memsz;
1081   uint flags;
1082   uint align;
1083 };
1084 
1085 
1086 #define ELF_PROG_LOAD           1
1087 
1088 
1089 #define ELF_PROG_FLAG_EXEC      1
1090 #define ELF_PROG_FLAG_WRITE     2
1091 #define ELF_PROG_FLAG_READ      4
1092 
1093 
1094 
1095 
1096 
1097 
1098 
1099 
1100 
1101 
1102 
1103 
1104 
1105 
1106 
1107 
1108 
1109 
1110 
1111 
1112 
1113 
1114 
1115 
1116 
1117 
1118 
1119 
1120 
1121 
1122 
1123 
1124 
1125 
1126 
1127 
1128 
1129 
1130 
1131 
1132 
1133 
1134 
1135 
1136 
1137 
1138 
1139 
1140 
1141 
1142 
1143 
1144 
1145 
1146 
1147 
1148 
1149 
1150 
1151 
1152 
1153 
1154 
1155 
1156 
1157 
1158 
1159 
1160 
1161 
1162 
1163 
1164 
1165 
1166 
1167 
1168 
1169 
1170 
1171 
1172 
1173 
1174 
1175 
1176 .p2align 2
1177 .text
1178 .globl multiboot_header
1179 multiboot_header:
1180   
1181   
1182   .long magic
1183   .long flags
1184   .long (-magic-flags)
1185 
1186 
1187 
1188 
1189 .globl _start
1190 _start = V2P_WO(entry)
1191 
1192 
1193 .globl entry
1194 entry:
1195   
1196   movl    %cr4, %eax
1197   orl     $(CR4_PSE), %eax
1198   movl    %eax, %cr4
1199   
1200   movl    $(V2P_WO(entrypgdir)), %eax
1201   movl    %eax, %cr3
1202   
1203   movl    %cr0, %eax
1204   orl     $(CR0_PG|CR0_WP), %eax
1205   movl    %eax, %cr0
1206 
1207   
1208   movl $(stack + KSTACKSIZE), %esp
1209 
1210   
1211   
1212   
1213   
1214   mov $main, %eax
1215   jmp *%eax
1216 
1217 .comm stack, KSTACKSIZE
1218 
1219 
1220 
1221 
1222 
1223 
1224 
1225 
1226 
1227 
1228 
1229 
1230 
1231 
1232 
1233 
1234 
1235 
1236 
1237 
1238 
1239 
1240 
1241 
1242 
1243 
1244 
1245 
1246 
1247 
1248 
1249 
1250 
1251 
1252 
1253 
1254 
1255 
1256 
1257 
1258 
1259 
1260 
1261 
1262 
1263 
1264 
1265 
1266 
1267 
1268 
1269 
1270 
1271 .code16
1272 .globl start
1273 start:
1274   cli
1275 
1276   
1277   xorw    %ax,%ax
1278   movw    %ax,%ds
1279   movw    %ax,%es
1280   movw    %ax,%ss
1281 
1282   
1283   
1284   
1285   lgdt    gdtdesc
1286   movl    %cr0, %eax
1287   orl     $CR0_PE, %eax
1288   movl    %eax, %cr0
1289 
1290   
1291   
1292   
1293   ljmpl    $(SEG_KCODE<<3), $(start32)
1294 
1295 
1296 
1297 
1298 
1299 
1300 .code32  
1301 start32:
1302   
1303   movw    $(SEG_KDATA<<3), %ax    
1304   movw    %ax, %ds                
1305   movw    %ax, %es                
1306   movw    %ax, %ss                
1307   movw    $0, %ax                 
1308   movw    %ax, %fs                
1309   movw    %ax, %gs                
1310 
1311   
1312   movl    %cr4, %eax
1313   orl     $(CR4_PSE), %eax
1314   movl    %eax, %cr4
1315   
1316   movl    (start-12), %eax
1317   movl    %eax, %cr3
1318   
1319   movl    %cr0, %eax
1320   orl     $(CR0_PE|CR0_PG|CR0_WP), %eax
1321   movl    %eax, %cr0
1322 
1323   
1324   movl    (start-4), %esp
1325   
1326   call	 *(start-8)
1327 
1328   movw    $0x8a00, %ax
1329   movw    %ax, %dx
1330   outw    %ax, %dx
1331   movw    $0x8ae0, %ax
1332   outw    %ax, %dx
1333 spin:
1334   jmp     spin
1335 
1336 .p2align 2
1337 gdt:
1338   SEG_NULLASM
1339   SEG_ASM(STA_X|STA_R, 0, 0xffffffff)
1340   SEG_ASM(STA_W, 0, 0xffffffff)
1341 
1342 
1343 gdtdesc:
1344   .word   (gdtdesc - gdt - 1)
1345   .long   gdt
1346 
1347 
1348 
1349 
1350 #include "types.h"
1351 #include "defs.h"
1352 #include "param.h"
1353 #include "memlayout.h"
1354 #include "mmu.h"
1355 #include "proc.h"
1356 #include "x86.h"
1357 
1358 static void startothers(void);
1359 static void mpmain(void)  __attribute__((noreturn));
1360 extern pde_t *kpgdir;
1361 extern char end[]; 
1362 
1363 
1364 
1365 
1366 int
1367 main(void)
1368 {
1369   kinit1(end, P2V(4*1024*1024)); 
1370   kvmalloc();      
1371   mpinit();        
1372   lapicinit();     
1373   seginit();       
1374   cprintf("\ncpu%d: starting xv6\n\n", cpunum());
1375   picinit();       
1376   ioapicinit();    
1377   consoleinit();   
1378   uartinit();      
1379   pinit();         
1380   tvinit();        
1381   binit();         
1382   fileinit();      
1383   ideinit();       
1384   if(!ismp)
1385     timerinit();   
1386   startothers();   
1387   kinit2(P2V(4*1024*1024), P2V(PHYSTOP)); 
1388   userinit();      
1389   mpmain();        
1390 }
1391 
1392 
1393 
1394 
1395 
1396 
1397 
1398 
1399 
1400 
1401 static void
1402 mpenter(void)
1403 {
1404   switchkvm();
1405   seginit();
1406   lapicinit();
1407   mpmain();
1408 }
1409 
1410 
1411 static void
1412 mpmain(void)
1413 {
1414   cprintf("cpu%d: starting\n", cpunum());
1415   idtinit();       
1416   xchg(&cpu->started, 1); 
1417   scheduler();     
1418 }
1419 
1420 pde_t entrypgdir[];  
1421 
1422 
1423 static void
1424 startothers(void)
1425 {
1426   extern uchar _binary_entryother_start[], _binary_entryother_size[];
1427   uchar *code;
1428   struct cpu *c;
1429   char *stack;
1430 
1431   
1432   
1433   
1434   code = P2V(0x7000);
1435   memmove(code, _binary_entryother_start, (uint)_binary_entryother_size);
1436 
1437   for(c = cpus; c < cpus+ncpu; c++){
1438     if(c == cpus+cpunum())  
1439       continue;
1440 
1441     
1442     
1443     
1444     stack = kalloc();
1445     *(void**)(code-4) = stack + KSTACKSIZE;
1446     *(void**)(code-8) = mpenter;
1447     *(int**)(code-12) = (void *) V2P(entrypgdir);
1448 
1449     lapicstartap(c->apicid, V2P(code));
1450     
1451     while(c->started == 0)
1452       ;
1453   }
1454 }
1455 
1456 
1457 
1458 
1459 
1460 
1461 __attribute__((__aligned__(PGSIZE)))
1462 pde_t entrypgdir[NPDENTRIES] = {
1463   
1464   [0] = (0) | PTE_P | PTE_W | PTE_PS,
1465   
1466   [KERNBASE>>PDXSHIFT] = (0) | PTE_P | PTE_W | PTE_PS,
1467 };
1468 
1469 
1470 
1471 
1472 
1473 
1474 
1475 
1476 
1477 
1478 
1479 
1480 
1481 
1482 
1483 
1484 
1485 
1486 
1487 
1488 
1489 
1490 
1491 
1492 
1493 
1494 
1495 
1496 
1497 
1498 
1499 
1500 
1501 
1502 
1503 
1504 
1505 
1506 
1507 
1508 
1509 
1510 
1511 
1512 
1513 
1514 
1515 
1516 
1517 
1518 
1519 
1520 
1521 
1522 
1523 
1524 
1525 
1526 
1527 
1528 
1529 
1530 
1531 
1532 
1533 
1534 
1535 
1536 
1537 
1538 
1539 
1540 
1541 
1542 
1543 
1544 
1545 
1546 
1547 
1548 
1549 
1550 
1551 struct spinlock {
1552   uint locked;       
1553 
1554   
1555   char *name;        
1556   struct cpu *cpu;   
1557   uint pcs[10];      
1558                      
1559 };
1560 
1561 
1562 
1563 
1564 
1565 
1566 
1567 
1568 
1569 
1570 
1571 
1572 
1573 
1574 
1575 
1576 
1577 
1578 
1579 
1580 
1581 
1582 
1583 
1584 
1585 
1586 
1587 
1588 
1589 
1590 
1591 
1592 
1593 
1594 
1595 
1596 
1597 
1598 
1599 
1600 
1601 
1602 #include "types.h"
1603 #include "defs.h"
1604 #include "param.h"
1605 #include "x86.h"
1606 #include "memlayout.h"
1607 #include "mmu.h"
1608 #include "proc.h"
1609 #include "spinlock.h"
1610 
1611 void
1612 initlock(struct spinlock *lk, char *name)
1613 {
1614   lk->name = name;
1615   lk->locked = 0;
1616   lk->cpu = 0;
1617 }
1618 
1619 
1620 
1621 
1622 
1623 void
1624 acquire(struct spinlock *lk)
1625 {
1626   pushcli(); 
1627   if(holding(lk)){
1628       cprintf("%s acquire\n",lk->name);
1629     
1630   }
1631 
1632   
1633   while(xchg(&lk->locked, 1) != 0)
1634     ;
1635 
1636   
1637   
1638   
1639   __sync_synchronize();
1640 
1641   
1642   lk->cpu = cpu;
1643   getcallerpcs(&lk, lk->pcs);
1644 }
1645 
1646 
1647 
1648 
1649 
1650 
1651 void
1652 release(struct spinlock *lk)
1653 {
1654   if(!holding(lk))
1655     panic("release");
1656 
1657   lk->pcs[0] = 0;
1658   lk->cpu = 0;
1659 
1660   
1661   
1662   
1663   
1664   
1665   __sync_synchronize();
1666 
1667   
1668   
1669   
1670   asm volatile("movl $0, %0" : "+m" (lk->locked) : );
1671 
1672   popcli();
1673 }
1674 
1675 
1676 void
1677 getcallerpcs(void *v, uint pcs[])
1678 {
1679   uint *ebp;
1680   int i;
1681 
1682   ebp = (uint*)v - 2;
1683   for(i = 0; i < 10; i++){
1684     if(ebp == 0 || ebp < (uint*)KERNBASE || ebp == (uint*)0xffffffff)
1685       break;
1686     pcs[i] = ebp[1];     
1687     ebp = (uint*)ebp[0]; 
1688   }
1689   for(; i < 10; i++)
1690     pcs[i] = 0;
1691 }
1692 
1693 
1694 int
1695 holding(struct spinlock *lock)
1696 {
1697   return lock->locked && lock->cpu == cpu;
1698 }
1699 
1700 
1701 
1702 
1703 
1704 void
1705 pushcli(void)
1706 {
1707   int eflags;
1708 
1709   eflags = readeflags();
1710   cli();
1711   if(cpu->ncli == 0)
1712     cpu->intena = eflags & FL_IF;
1713   cpu->ncli += 1;
1714 }
1715 
1716 void
1717 popcli(void)
1718 {
1719   if(readeflags()&FL_IF)
1720     panic("popcli - interruptible");
1721   if(--cpu->ncli < 0)
1722     panic("popcli");
1723   if(cpu->ncli == 0 && cpu->intena)
1724     sti();
1725 }
1726 
1727 
1728 
1729 
1730 
1731 
1732 
1733 
1734 
1735 
1736 
1737 
1738 
1739 
1740 
1741 
1742 
1743 
1744 
1745 
1746 
1747 
1748 
1749 
1750 #include "param.h"
1751 #include "types.h"
1752 #include "defs.h"
1753 #include "x86.h"
1754 #include "memlayout.h"
1755 #include "mmu.h"
1756 #include "proc.h"
1757 #include "elf.h"
1758 
1759 extern char data[];  
1760 pde_t *kpgdir;  
1761 
1762 
1763 
1764     void
1765 seginit(void)
1766 {
1767     struct cpu *c;
1768 
1769     
1770     
1771     
1772     
1773     c = &cpus[cpunum()];
1774     c->gdt[SEG_KCODE] = SEG(STA_X|STA_R, 0, 0xffffffff, 0);
1775     c->gdt[SEG_KDATA] = SEG(STA_W, 0, 0xffffffff, 0);
1776     c->gdt[SEG_UCODE] = SEG(STA_X|STA_R, 0, 0xffffffff, DPL_USER);
1777     c->gdt[SEG_UDATA] = SEG(STA_W, 0, 0xffffffff, DPL_USER);
1778 
1779     
1780     c->gdt[SEG_KCPU] = SEG(STA_W, &c->cpu, 8, 0);
1781 
1782     lgdt(c->gdt, sizeof(c->gdt));
1783     loadgs(SEG_KCPU << 3);
1784 
1785     
1786     cpu = c;
1787     proc = 0;
1788 }
1789 
1790 
1791 
1792 
1793 
1794 
1795 
1796 
1797 
1798 
1799 
1800 
1801 
1802 
1803     static pte_t *
1804 walkpgdir(pde_t *pgdir, const void *va, int alloc)
1805 {
1806     pde_t *pde;
1807     pte_t *pgtab;
1808 
1809     pde = &pgdir[PDX(va)];
1810     if(*pde & PTE_P){
1811         pgtab = (pte_t*)P2V(PTE_ADDR(*pde));
1812     } else {
1813         if(!alloc || (pgtab = (pte_t*)kalloc()) == 0)
1814             return 0;
1815         
1816         memset(pgtab, 0, PGSIZE);
1817         
1818         
1819         
1820         *pde = V2P(pgtab) | PTE_P | PTE_W | PTE_U;
1821     }
1822     return &pgtab[PTX(va)];
1823 }
1824 
1825 
1826 
1827 
1828     static int
1829 mappages(pde_t *pgdir, void *va, uint size, uint pa, int perm)
1830 {
1831     char *a, *last;
1832     pte_t *pte;
1833 
1834     a = (char*)PGROUNDDOWN((uint)va);
1835     last = (char*)PGROUNDDOWN(((uint)va) + size - 1);
1836     for(;;){
1837         if((pte = walkpgdir(pgdir, a, 1)) == 0)
1838             return -1;
1839         if(*pte & PTE_P)
1840             panic("remap");
1841         *pte = pa | perm | PTE_P;
1842         if(a == last)
1843             break;
1844         a += PGSIZE;
1845         pa += PGSIZE;
1846     }
1847     return 0;
1848 }
1849 
1850 
1851 
1852 
1853 
1854 
1855 
1856 
1857 
1858 
1859 
1860 
1861 
1862 
1863 
1864 
1865 
1866 
1867 
1868 
1869 
1870 
1871 
1872 
1873 static struct kmap {
1874     void *virt;
1875     uint phys_start;
1876     uint phys_end;
1877     int perm;
1878 } kmap[] = {
1879     { (void*)KERNBASE, 0,             EXTMEM,    PTE_W}, 
1880     { (void*)KERNLINK, V2P(KERNLINK), V2P(data), 0},     
1881     { (void*)data,     V2P(data),     PHYSTOP,   PTE_W}, 
1882     { (void*)DEVSPACE, DEVSPACE,      0,         PTE_W}, 
1883 };
1884 
1885 
1886     pde_t*
1887 setupkvm(void)
1888 {
1889     pde_t *pgdir;
1890     struct kmap *k;
1891 
1892     if((pgdir = (pde_t*)kalloc()) == 0)
1893         return 0;
1894     memset(pgdir, 0, PGSIZE);
1895     if (P2V(PHYSTOP) > (void*)DEVSPACE)
1896         panic("PHYSTOP too high");
1897     for(k = kmap; k < &kmap[NELEM(kmap)]; k++)
1898         if(mappages(pgdir, k->virt, k->phys_end - k->phys_start,
1899                     (uint)k->phys_start, k->perm) < 0)
1900             return 0;
1901     return pgdir;
1902 }
1903 
1904 
1905 
1906     void
1907 kvmalloc(void)
1908 {
1909     kpgdir = setupkvm();
1910     switchkvm();
1911 }
1912 
1913 
1914 
1915     void
1916 switchkvm(void)
1917 {
1918     lcr3(V2P(kpgdir));   
1919 }
1920 
1921 
1922     void
1923 switchuvm(struct proc *p)
1924 {
1925     if(p == 0)
1926         panic("switchuvm: no process");
1927     if(p->kstack == 0)
1928         panic("switchuvm: no kstack");
1929     if(p->pgdir == 0)
1930         panic("switchuvm: no pgdir");
1931 
1932     pushcli();
1933     cpu->gdt[SEG_TSS] = SEG16(STS_T32A, &cpu->ts, sizeof(cpu->ts)-1, 0);
1934     cpu->gdt[SEG_TSS].s = 0;
1935     cpu->ts.ss0 = SEG_KDATA << 3;
1936     cpu->ts.esp0 = (uint)p->kstack + KSTACKSIZE;
1937     
1938     
1939     cpu->ts.iomb = (ushort) 0xFFFF;
1940     ltr(SEG_TSS << 3);
1941     lcr3(V2P(p->pgdir));  
1942     popcli();
1943 }
1944 
1945 
1946 
1947 
1948 
1949 
1950 
1951 
1952     void
1953 inituvm(pde_t *pgdir, char *init, uint sz)
1954 {
1955     char *mem;
1956 
1957     if(sz >= PGSIZE)
1958         panic("inituvm: more than a page");
1959     mem = kalloc();
1960     memset(mem, 0, PGSIZE);
1961     mappages(pgdir, 0, PGSIZE, V2P(mem), PTE_W|PTE_U);
1962     memmove(mem, init, sz);
1963 }
1964 
1965 
1966 
1967     int
1968 loaduvm(pde_t *pgdir, char *addr, struct inode *ip, uint offset, uint sz)
1969 {
1970     uint i, pa, n;
1971     pte_t *pte;
1972 
1973     if((uint) addr % PGSIZE != 0)
1974         panic("loaduvm: addr must be page aligned");
1975     for(i = 0; i < sz; i += PGSIZE){
1976         if((pte = walkpgdir(pgdir, addr+i, 0)) == 0)
1977             panic("loaduvm: address should exist");
1978         pa = PTE_ADDR(*pte);
1979         if(sz - i < PGSIZE)
1980             n = sz - i;
1981         else
1982             n = PGSIZE;
1983         if(readi(ip, P2V(pa), offset+i, n) != n)
1984             return -1;
1985     }
1986     return 0;
1987 }
1988 
1989 
1990 
1991 
1992 
1993 
1994 
1995 
1996 
1997 
1998 
1999 
2000 
2001 
2002     int
2003 allocuvm(pde_t *pgdir, uint oldsz, uint newsz)
2004 {
2005     char *mem;
2006     uint a;
2007 
2008     if(newsz >= KERNBASE)
2009         return 0;
2010     if(newsz < oldsz)
2011         return oldsz;
2012 
2013     a = PGROUNDUP(oldsz);
2014     for(; a < newsz; a += PGSIZE){
2015         mem = kalloc();
2016         if(mem == 0){
2017             cprintf("allocuvm out of memory\n");
2018             deallocuvm(pgdir, newsz, oldsz);
2019             return 0;
2020         }
2021         memset(mem, 0, PGSIZE);
2022         if(mappages(pgdir, (char*)a, PGSIZE, V2P(mem), PTE_W|PTE_U) < 0){
2023             cprintf("allocuvm out of memory (2)\n");
2024             deallocuvm(pgdir, newsz, oldsz);
2025             kfree(mem);
2026             return 0;
2027         }
2028     }
2029     return newsz;
2030 }
2031 
2032 
2033 
2034 
2035 
2036     int
2037 deallocuvm(pde_t *pgdir, uint oldsz, uint newsz)
2038 {
2039     pte_t *pte;
2040     uint a, pa;
2041 
2042     if(newsz >= oldsz)
2043         return oldsz;
2044 
2045     a = PGROUNDUP(newsz);
2046     for(; a  < oldsz; a += PGSIZE){
2047         pte = walkpgdir(pgdir, (char*)a, 0);
2048         if(!pte)
2049             a = PGADDR(PDX(a) + 1, 0, 0) - PGSIZE;
2050         else if((*pte & PTE_P) != 0){
2051             pa = PTE_ADDR(*pte);
2052             if(pa == 0)
2053                 panic("kfree");
2054             char *v = P2V(pa);
2055             kfree(v);
2056             *pte = 0;
2057         }
2058     }
2059     return newsz;
2060 }
2061 
2062 
2063 
2064     void
2065 freevm(pde_t *pgdir)
2066 {
2067     uint i;
2068 
2069     if(pgdir == 0)
2070         panic("freevm: no pgdir");
2071     deallocuvm(pgdir, KERNBASE, 0);
2072     for(i = 0; i < NPDENTRIES; i++){
2073         if(pgdir[i] & PTE_P){
2074             char * v = P2V(PTE_ADDR(pgdir[i]));
2075             kfree(v);
2076         }
2077     }
2078     kfree((char*)pgdir);
2079 }
2080 
2081 
2082 
2083     void
2084 clearpteu(pde_t *pgdir, char *uva)
2085 {
2086     pte_t *pte;
2087 
2088     pte = walkpgdir(pgdir, uva, 0);
2089     if(pte == 0)
2090         panic("clearpteu");
2091     *pte &= ~PTE_U;
2092 }
2093 
2094 
2095 
2096 
2097 
2098 
2099 
2100 
2101 
2102     pde_t*
2103 copyuvm(pde_t *pgdir, uint sz)
2104 {
2105     pde_t *d;
2106     pte_t *pte;
2107     uint pa, i, flags;
2108     char *mem;
2109 
2110     if((d = setupkvm()) == 0)
2111         return 0;
2112     for(i = 0; i < sz; i += PGSIZE){
2113         if((pte = walkpgdir(pgdir, (void *) i, 0)) == 0)
2114             panic("copyuvm: pte should exist");
2115         if(!(*pte & PTE_P))
2116             panic("copyuvm: page not present");
2117         pa = PTE_ADDR(*pte);
2118         flags = PTE_FLAGS(*pte);
2119         if((mem = kalloc()) == 0)
2120             goto bad;
2121         memmove(mem, (char*)P2V(pa), PGSIZE);
2122         if(mappages(d, (void*)i, PGSIZE, V2P(mem), flags) < 0)
2123             goto bad;
2124     }
2125     return d;
2126 
2127 bad:
2128     freevm(d);
2129     return 0;
2130 }
2131 
2132 
2133 
2134 
2135 
2136 
2137 
2138 
2139 
2140 
2141 
2142 
2143 
2144 
2145 
2146 
2147 
2148 
2149 
2150 
2151     char*
2152 uva2ka(pde_t *pgdir, char *uva)
2153 {
2154     pte_t *pte;
2155 
2156     pte = walkpgdir(pgdir, uva, 0);
2157     if((*pte & PTE_P) == 0)
2158         return 0;
2159     if((*pte & PTE_U) == 0)
2160         return 0;
2161     return (char*)P2V(PTE_ADDR(*pte));
2162 }
2163 
2164 
2165 
2166 
2167     int
2168 copyout(pde_t *pgdir, uint va, void *p, uint len)
2169 {
2170     char *buf, *pa0;
2171     uint n, va0;
2172 
2173     buf = (char*)p;
2174     while(len > 0){
2175         va0 = (uint)PGROUNDDOWN(va);
2176         pa0 = uva2ka(pgdir, (char*)va0);
2177         if(pa0 == 0)
2178             return -1;
2179         n = PGSIZE - (va - va0);
2180         if(n > len)
2181             n = len;
2182         memmove(pa0 + (va - va0), buf, n);
2183         len -= n;
2184         buf += n;
2185         va = va0 + PGSIZE;
2186     }
2187     return 0;
2188 }
2189 
2190 
2191 
2192 
2193 
2194 
2195 
2196 
2197 
2198 
2199 
2200 
2201 
2202 
2203 
2204 
2205 
2206 
2207 
2208 
2209 
2210 
2211 
2212 
2213 
2214 
2215 
2216 
2217 
2218 
2219 
2220 
2221 
2222 
2223 
2224 
2225 
2226 
2227 
2228 
2229 
2230 
2231 
2232 
2233 
2234 
2235 
2236 
2237 
2238 
2239 
2240 
2241 
2242 
2243 
2244 
2245 
2246 
2247 
2248 
2249 
2250 
2251 
2252 
2253 
2254 
2255 
2256 
2257 
2258 
2259 
2260 
2261 
2262 
2263 
2264 
2265 
2266 
2267 
2268 
2269 
2270 
2271 
2272 
2273 
2274 
2275 
2276 
2277 
2278 
2279 
2280 
2281 
2282 
2283 
2284 
2285 
2286 
2287 
2288 
2289 
2290 
2291 
2292 
2293 
2294 
2295 
2296 
2297 
2298 
2299 
2300 
2301 
2302 
2303 
2304 void
2305 empty_stack_clean(struct proc *p){
2306     int* run;
2307     pte_t *pte;
2308     uint pa;
2309 
2310     run = (int*)p->sz;
2311     for(;(int)run > p->tf->ebp; run -= 1){
2312 
2313         pte = walkpgdir(p->pgdir, run, 0);
2314         if(!pte){
2315             run = (int*)(PGADDR(PDX(*run) + 1, 0, 0) - PGSIZE);
2316         }else if((*pte & PTE_P) != 0){
2317             pa = PTE_ADDR(*pte);
2318             if(pa == 0) continue;
2319             break;
2320         }
2321     }
2322     p->sz = (int)run;
2323 
2324 }
2325 
2326 
2327     pde_t*
2328 copyuvm_force(pde_t *pgdir, uint sz)
2329 {
2330     pde_t *d;
2331     pte_t *pte;
2332     uint pa, i, flags;
2333     char *mem;
2334 
2335     if((d = setupkvm()) == 0)
2336         return 0;
2337     for(i = 0; i < sz; i += PGSIZE){
2338         if((pte = walkpgdir(pgdir, (void *) i, 0)) == 0)
2339             panic("copyuvm: pte should exist");
2340         if(!(*pte & PTE_P))
2341             continue;
2342         pa = PTE_ADDR(*pte);
2343         *pte = *pte | PTE_P;
2344         flags = PTE_FLAGS(*pte);
2345         if((mem = kalloc()) == 0)
2346             goto bad;
2347         memmove(mem, (char*)P2V(pa), PGSIZE);
2348         if(mappages(d, (void*)i, PGSIZE, V2P(mem), flags) < 0)
2349             goto bad;
2350     }
2351     return d;
2352 
2353 bad:
2354     freevm(d);
2355     return 0;
2356 }
2357 
2358 
2359 
2360 
2361 
2362 
2363 
2364 
2365 
2366 
2367 
2368 
2369 
2370 
2371 
2372 
2373 
2374 
2375 
2376 
2377 
2378 
2379 
2380 
2381 
2382 
2383 
2384 
2385 
2386 
2387 
2388 
2389 
2390 
2391 
2392 
2393 
2394 
2395 
2396 
2397 
2398 
2399 
2400 
2401 struct cpu {
2402     uchar apicid;                
2403     struct context *scheduler;   
2404     struct taskstate ts;         
2405     struct segdesc gdt[NSEGS];   
2406     volatile uint started;       
2407     int ncli;                    
2408     int intena;                  
2409 
2410     
2411     struct cpu *cpu;
2412     struct proc *proc;           
2413 };
2414 
2415 extern struct cpu cpus[NCPU];
2416 extern int ncpu;
2417 
2418 
2419 
2420 
2421 
2422 
2423 
2424 
2425 
2426 extern struct cpu *cpu asm("%gs:0");       
2427 extern struct proc *proc asm("%gs:4");     
2428 
2429 
2430 
2431 
2432 
2433 
2434 
2435 
2436 
2437 
2438 
2439 
2440 struct context {
2441     uint edi;
2442     uint esi;
2443     uint ebx;
2444     uint ebp;
2445     uint eip;
2446 };
2447 
2448 
2449 
2450 enum procstate { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };
2451 
2452 
2453 struct proc {
2454     uint sz;                     
2455     pde_t* pgdir;                
2456     char *kstack;                
2457     enum procstate state;        
2458     int pid;                     
2459     struct proc *parent;         
2460     struct trapframe *tf;        
2461     struct context *context;     
2462     void *chan;                  
2463     int killed;                  
2464     struct file *ofile[NOFILE];  
2465     struct inode *cwd;           
2466     char name[16];               
2467 
2468     
2469     ushort qPosi;
2470     ushort stride; 
2471     ushort pstride; 
2472     unsigned long int pass; 
2473     uint consumedTime; 
2474 
2475     ushort isthread;
2476     ushort numOfThread;
2477     int stack;
2478     void *retval;
2479     int tid;
2480 
2481 
2482 };
2483 
2484 
2485 
2486 
2487 
2488 
2489 
2490 
2491 
2492 
2493 
2494 
2495 
2496 
2497 
2498 
2499 
2500 #include "types.h"
2501 #include "defs.h"
2502 #include "param.h"
2503 #include "memlayout.h"
2504 #include "mmu.h"
2505 #include "x86.h"
2506 #include "proc.h"
2507 #include "mlfq.h"
2508 #include "stride.h"
2509 #include "thread.h"
2510 #include "spinlock.h"
2511 
2512 struct {
2513     struct spinlock lock;
2514     struct proc proc[NPROC];
2515 } ptable;
2516 
2517 static struct proc *initproc;
2518 
2519 int nextpid = 1;
2520 int nexttid = 1000;
2521 extern void forkret(void);
2522 extern void trapret(void);
2523 
2524 static void wakeup1(void *chan);
2525 
2526     void
2527 pinit(void)
2528 {
2529     initlock(&ptable.lock, "ptable");
2530 }
2531 
2532 
2533 
2534 
2535 
2536 
2537 
2538 
2539 
2540 
2541 
2542 
2543 
2544 
2545 
2546 
2547 
2548 
2549 
2550 
2551 
2552 
2553 
2554     static struct proc*
2555 allocproc(void)
2556 {
2557     struct proc *p;
2558     char *sp;
2559 
2560     acquire(&ptable.lock);
2561 
2562     for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
2563         if(p->state == UNUSED)
2564             goto found;
2565 
2566     release(&ptable.lock);
2567     return 0;
2568 
2569 found:
2570     p->state = EMBRYO;
2571     p->pid = nextpid++;
2572     
2573     p->tid = 0;
2574     p->isthread = 0;
2575     p->numOfThread = 0;
2576 
2577     release(&ptable.lock);
2578 
2579     
2580     if((p->kstack = kalloc()) == 0){
2581         p->state = UNUSED;
2582         return 0;
2583     }
2584     sp = p->kstack + KSTACKSIZE;
2585 
2586     
2587     sp -= sizeof *p->tf;
2588     p->tf = (struct trapframe*)sp;
2589 
2590     
2591     
2592     sp -= 4;
2593     *(uint*)sp = (uint)trapret;
2594 
2595     sp -= sizeof *p->context;
2596     p->context = (struct context*)sp;
2597     memset(p->context, 0, sizeof *p->context);
2598     p->context->eip = (uint)forkret;
2599 
2600     return p;
2601 }
2602 
2603 
2604 
2605     void
2606 userinit(void)
2607 {
2608     struct proc *p;
2609     extern char _binary_initcode_start[], _binary_initcode_size[];
2610 
2611     p = allocproc();
2612 
2613     initproc = p;
2614     if((p->pgdir = setupkvm()) == 0)
2615         panic("userinit: out of memory?");
2616     inituvm(p->pgdir, _binary_initcode_start, (int)_binary_initcode_size);
2617     p->sz = PGSIZE;
2618     memset(p->tf, 0, sizeof(*p->tf));
2619     p->tf->cs = (SEG_UCODE << 3) | DPL_USER;
2620     p->tf->ds = (SEG_UDATA << 3) | DPL_USER;
2621     p->tf->es = p->tf->ds;
2622     p->tf->ss = p->tf->ds;
2623     p->tf->eflags = FL_IF;
2624     p->tf->esp = PGSIZE;
2625     p->tf->eip = 0;  
2626 
2627     safestrcpy(p->name, "initcode", sizeof(p->name));
2628     p->cwd = namei("/");
2629 
2630     
2631     
2632     
2633     
2634     acquire(&ptable.lock);
2635 
2636     p->state = RUNNABLE;
2637 
2638     release(&ptable.lock);
2639 }
2640 
2641 
2642 
2643 
2644 
2645 
2646 
2647 
2648 
2649 
2650 
2651 
2652     int
2653 growproc(int n)
2654 {
2655     uint sz;
2656 
2657     
2658     acquire(&ptable.lock);
2659 
2660     sz = proc->sz;
2661     if(n > 0){
2662         if((sz = allocuvm(proc->pgdir, sz, sz + n)) == 0)
2663             return -1;
2664     } else if(n < 0){
2665         if((sz = deallocuvm(proc->pgdir, sz, sz + n)) == 0)
2666             return -1;
2667     }
2668     
2669     if(proc->isthread == 1){
2670         proc->parent->sz = sz;
2671     }
2672     proc->sz = sz;
2673     release(&ptable.lock);
2674 
2675     switchuvm(proc);
2676     return 0;
2677 }
2678 
2679 
2680 
2681 
2682     int
2683 fork(void)
2684 {
2685     int i, pid;
2686     struct proc *np;
2687     
2688 
2689 
2690     if(proc->isthread == 1){
2691         return thread_fork();
2692     }
2693 
2694 
2695     
2696     if((np = allocproc()) == 0){
2697         return -1;
2698     }
2699 
2700     
2701     if((np->pgdir = copyuvm(proc->pgdir, proc->sz)) == 0){
2702         kfree(np->kstack);
2703         np->kstack = 0;
2704         np->state = UNUSED;
2705         return -1;
2706     }
2707     np->sz = proc->sz;
2708     np->parent = proc;
2709     *np->tf = *proc->tf;
2710 
2711     
2712     np->tf->eax = 0;
2713 
2714     for(i = 0; i < NOFILE; i++)
2715         if(proc->ofile[i])
2716             np->ofile[i] = filedup(proc->ofile[i]);
2717     np->cwd = idup(proc->cwd);
2718 
2719     safestrcpy(np->name, proc->name, sizeof(proc->name));
2720 
2721     pid = np->pid;
2722 
2723     acquire(&ptable.lock);
2724 
2725     np->state = RUNNABLE;
2726     
2727     enqueue(&qOfM[0],np);
2728 
2729     release(&ptable.lock);
2730 
2731     return pid;
2732 }
2733 
2734 
2735 
2736 
2737     void
2738 exit(void)
2739 {
2740     struct proc *p;
2741     int fd;
2742     int c_retval = 0;
2743 
2744 
2745     if(proc->isthread == 1){
2746         return clean(proc->parent);
2747 
2748     }
2749 
2750     if(proc == initproc)
2751         panic("init exiting");
2752 
2753     
2754     for(fd = 0; fd < NOFILE; fd++){
2755         if(proc->ofile[fd]){
2756             fileclose(proc->ofile[fd]);
2757             proc->ofile[fd] = 0;
2758         }
2759     }
2760 
2761     begin_op();
2762     iput(proc->cwd);
2763     end_op();
2764     proc->cwd = 0;
2765 
2766     acquire(&ptable.lock);
2767 
2768     
2769     wakeup1(proc->parent);
2770 
2771     /* COMMENT
2772        cprintf("-----------Before------------\n");
2773        printPtable();
2774        */
2775 
2776 
2777     
2778     for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
2779         if(p->parent == proc){
2780             
2781             if(p->isthread == 1){
2782                 release(&ptable.lock);
2783                 thread_clean(p->tid,(void**)c_retval);
2784                 acquire(&ptable.lock);
2785             }
2786 
2787             p->parent = initproc;
2788             if(p->state == ZOMBIE){
2789                 wakeup1(initproc);
2790             }
2791         }
2792     }
2793 
2794 
2795     
2796     
2797     if(proc->stride == 0)dequeue(&qOfM[proc->qPosi],proc);
2798     proc->consumedTime = 0;
2799     if(proc->pid > 2 )cut_cpu_share(proc->stride);
2800     proc->stride = 0;
2801     proc->pass = 0;
2802     proc->qPosi = 0;
2803 
2804     
2805     wakeup1(proc->parent);
2806 
2807     proc->state = ZOMBIE;
2808 
2809 
2810     /*COMMENT
2811       cprintf("-----------After------------\n");
2812     cprintf(    "exi : %d in : %d\n",proc->pid, proc->qPosi);
2813       printPtable();
2814       */
2815 
2816     sched();
2817     panic("zombie exit");
2818 
2819 
2820 }
2821 
2822 
2823     int
2824 wait(void)
2825 {
2826     struct proc *p;
2827     int havekids, pid;
2828     
2829 
2830     acquire(&ptable.lock);
2831     for(;;){
2832         
2833         havekids = 0;
2834         for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
2835             if(p->parent != proc )
2836                 continue;
2837             if(p->isthread == 1)
2838                 continue;
2839             havekids = 1;
2840             if(p->state == ZOMBIE){
2841                 
2842                 pid = p->pid;
2843                 kfree(p->kstack);
2844                 p->kstack = 0;
2845                 freevm(p->pgdir);
2846                 p->pid = 0;
2847                 p->parent = 0;
2848                 p->name[0] = 0;
2849                 p->killed = 0;
2850                 p->state = UNUSED;
2851                 release(&ptable.lock);
2852                 return pid;
2853             }
2854         }
2855 
2856         
2857         if(!havekids || proc->killed){
2858             release(&ptable.lock);
2859             return -1;
2860         }
2861 
2862         
2863         sleep(proc, &ptable.lock);  
2864     }
2865 }
2866 
2867 
2868 
2869 
2870 
2871 
2872 
2873 
2874 
2875 
2876 
2877 
2878 
2879 
2880 
2881 
2882 
2883 
2884 
2885 
2886 
2887 
2888 
2889 
2890 
2891 
2892 
2893 
2894 
2895 
2896 
2897 
2898 
2899 
2900 
2901 
2902 
2903 
2904 
2905 
2906 
2907     void
2908 scheduler(void)
2909 {
2910     struct proc *p;
2911     int i = 0;
2912     struct Mlfq* nextQ;
2913     int checkQ = 0; 
2914     curQ = 0;
2915     MlfqProcFlag = 0;
2916 
2917     initMlfq(&qOfM[0]);
2918     initMlfq(&qOfM[1]);
2919     initMlfq(&qOfM[2]);
2920     initMlfqGlobal();
2921     initStride();
2922 
2923     acquire(&ptable.lock);
2924     for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
2925         if(p->state == UNUSED)
2926             continue;
2927         enqueue(&qOfM[0],p);
2928     }
2929     release(&ptable.lock);
2930 
2931 
2932 
2933     for(;;){
2934         
2935         sti();
2936 
2937         nextQ = &qOfM[curQ];
2938         schedulerMode = 0;
2939 
2940         checkRcount(&qOfM[0]);
2941         checkRcount(&qOfM[1]);
2942         checkRcount(&qOfM[2]);
2943 
2944         if(qOfM[0].rCount != 0){
2945             curQ = 0;
2946         }else if(qOfM[1].rCount != 0){
2947             curQ = 1;
2948         }else if(qOfM[2].rCount != 0){
2949             curQ = 2;
2950         }else curQ =0;
2951         checkQ = curQ;
2952         nextQ = &qOfM[curQ];
2953 
2954 
2955 
2956         
2957         acquire(&ptable.lock);
2958 
2959         for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
2960             findMinPassStride();
2961             if(minPass == MlfqPass){
2962                 schedulerMode = 1;
2963                 break;
2964             }
2965             if(p->pass != minPass || p->stride == 0)
2966                 continue;
2967             if(p->state != RUNNABLE )
2968                 continue;
2969 
2970             p->pass += p->stride;
2971 
2972             schedulerMode =0;
2973 
2974             proc = p;
2975             switchuvm(p);
2976             p->state = RUNNING;
2977             swtch(&cpu->scheduler, p->context);
2978             switchkvm();
2979 
2980             proc = 0;
2981         }
2982 
2983         if(schedulerMode == 1)
2984         {
2985             for(p = peekMlfq(nextQ); p; p = idxPeekMlfq(nextQ,i)){
2986 
2987                 if(qOfM[0].rCount != 0){
2988                     curQ = 0;
2989                 }else if(qOfM[1].rCount != 0){
2990                     curQ = 1;
2991                 }else if(qOfM[2].rCount != 0){
2992                     curQ = 2;
2993                 }else curQ =0;
2994                 if(checkQ != curQ) break;
2995 
2996 
2997 
2998 
2999 
3000                 if(p->state != RUNNABLE){
3001                     i++;;
3002                     continue;
3003                 }
3004 
3005 
3006                 i=0;
3007 
3008                 proc = p;
3009                 switchuvm(p);
3010                 p->state = RUNNING;
3011                 swtch(&cpu->scheduler, p->context);
3012                 switchkvm();
3013 
3014                 proc = 0;
3015             }
3016 
3017             MlfqPass += MlfqStride;
3018         }
3019         release(&ptable.lock);
3020     }
3021 }
3022 
3023 
3024 
3025 
3026 
3027 
3028 
3029 
3030     void
3031 sched(void)
3032 {
3033     int intena;
3034 
3035     if(!holding(&ptable.lock))
3036         panic("sched ptable.lock");
3037     if(cpu->ncli != 1)
3038         panic("sched locks");
3039     if(proc->state == RUNNING)
3040         panic("sched running");
3041     if(readeflags()&FL_IF)
3042         panic("sched interruptible");
3043     intena = cpu->intena;
3044     swtch(&proc->context, cpu->scheduler);
3045     cpu->intena = intena;
3046 }
3047 
3048 
3049 
3050 
3051     void
3052 yield(void)
3053 {
3054     
3055     acquire(&ptable.lock);  
3056     if(yieldbytimer == 0 && proc->stride == 0 && schedulerMode == 1){
3057 
3058         dequeue(&qOfM[proc->qPosi],proc);
3059         enqueue(&qOfM[proc->qPosi], proc);
3060     }
3061     proc->state = RUNNABLE;
3062     yieldbytimer = 0;
3063     sched();
3064     release(&ptable.lock);
3065 }
3066 
3067 
3068 
3069     void
3070 forkret(void)
3071 {
3072     static int first = 1;
3073     
3074     release(&ptable.lock);
3075 
3076     if (first) {
3077         
3078         
3079         
3080         first = 0;
3081         iinit(ROOTDEV);
3082         initlog(ROOTDEV);
3083     }
3084 
3085     
3086 }
3087 
3088 
3089 
3090 
3091 
3092 
3093 
3094 
3095 
3096 
3097 
3098 
3099 
3100 
3101 
3102     void
3103 sleep(void *chan, struct spinlock *lk)
3104 {
3105     if(proc == 0)
3106         panic("sleep");
3107 
3108     if(lk == 0)
3109         panic("sleep without lk");
3110 
3111     
3112     
3113     
3114     
3115     
3116     
3117     if(lk != &ptable.lock){  
3118         acquire(&ptable.lock);  
3119         release(lk);
3120     }
3121 
3122     
3123     proc->chan = chan;
3124     proc->state = SLEEPING;
3125 
3126     
3127     sched();
3128 
3129     
3130     
3131     proc->chan = 0;
3132 
3133     
3134     if(lk != &ptable.lock){  
3135         release(&ptable.lock);
3136         acquire(lk);
3137     }
3138 }
3139 
3140 
3141 
3142 
3143 
3144 
3145 
3146 
3147 
3148 
3149 
3150 
3151 
3152     static void
3153 wakeup1(void *chan)
3154 {
3155     struct proc *p;
3156 
3157     for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
3158         if(p->state == SLEEPING && p->chan == chan){
3159             p->state = RUNNABLE;
3160         }
3161 }
3162 
3163 
3164     void
3165 wakeup(void *chan)
3166 {
3167     acquire(&ptable.lock);
3168     wakeup1(chan);
3169     release(&ptable.lock);
3170 }
3171 
3172 
3173 
3174 
3175     int
3176 kill(int pid)
3177 {
3178 
3179     struct proc *p;
3180 
3181     acquire(&ptable.lock);
3182     for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
3183         if(p->pid == pid){
3184             p->killed = 1;
3185             
3186             if(p->state == SLEEPING)
3187                 p->state = RUNNABLE;
3188             release(&ptable.lock);
3189             return 0;
3190         }
3191     }
3192     release(&ptable.lock);
3193     return -1;
3194 }
3195 
3196 
3197 
3198 
3199 
3200 
3201 
3202 
3203     void
3204 procdump(void)
3205 {
3206     static char *states[] = {
3207         [UNUSED]    "unused",
3208         [EMBRYO]    "embryo",
3209         [SLEEPING]  "sleep ",
3210         [RUNNABLE]  "runble",
3211         [RUNNING]   "run   ",
3212         [ZOMBIE]    "zombie"
3213     };
3214     int i;
3215     struct proc *p;
3216     char *state;
3217     uint pc[10];
3218 
3219     for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
3220         if(p->state == UNUSED)
3221             continue;
3222         if(p->state >= 0 && p->state < NELEM(states) && states[p->state])
3223             state = states[p->state];
3224         else
3225             state = "???";
3226         cprintf("%d %s %s", p->pid, state, p->name);
3227         if(p->state == SLEEPING){
3228             getcallerpcs((uint*)p->context->ebp+2, pc);
3229             for(i=0; i<10 && pc[i] != 0; i++)
3230                 cprintf(" %p", pc[i]);
3231         }
3232         cprintf("\n");
3233     }
3234 }
3235 
3236 
3237 
3238 
3239 
3240 
3241 
3242 
3243 
3244 
3245 
3246 
3247 
3248 
3249 
3250 
3251 
3252 
3253     void
3254 findMinPassStride(void)
3255 {
3256     struct proc* p;
3257     int overflowFlag = 0;
3258 
3259     minPass = MlfqPass;
3260     if(minPass >= 2147483647 - 20000){
3261         overflowFlag = 1;
3262     }
3263 
3264     for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
3265         if(p->state != RUNNABLE)
3266             continue;
3267         if(p->pass >= 2147483647 - 20000){
3268             /*
3269                cprintf("[Warning] stride pass overflow~~-    -   -   -   -   -   -   -   -   -   -   -\n");
3270                cprintf(" Let OS manage pass of processes~~-    -   -   -   -   -   -   -   -   -   -   -\n");
3271                */
3272             overflowFlag = 1;
3273         }
3274         if(p->stride >0 && p->pass <= minPass){
3275             minPass = p->pass;
3276         }
3277     }
3278 
3279     if(overflowFlag == 1){
3280         for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
3281             if(p->state != RUNNABLE)
3282                 continue;
3283             if(p->pass > 0){
3284                 p->pass = p->pass - minPass + 10;
3285             }
3286         }
3287         MlfqPass = MlfqPass - minPass + 10;
3288         overflowFlag = 0;
3289     }
3290 }
3291 
3292 
3293 
3294 
3295 
3296 
3297 
3298 
3299 
3300 
3301     void
3302 printPtable(void)
3303 {
3304     struct proc* p;
3305 
3306     cprintf("hello~~~~~~\n");
3307     cprintf(" Mlfq:: / stride %d / pass %d\n",MlfqStride, MlfqPass);
3308     for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
3309         if(p->pid != 0)
3310             cprintf(" pid %d / tid %d/ ppid %d/ ptid %d/ name %s /state %d / cT %d / stride %d / p-s %d/ pass %d / n-o-t %d\n",\
3311                     p->pid,p->tid, p->parent->pid, p->parent->tid, p->name, p->state,p->consumedTime, p->stride, p->pstride, p->pass, p->numOfThread);
3312 
3313     }
3314 }
3315 
3316 
3317 
3318     static struct proc*
3319 allocthread(void)
3320 {
3321     struct proc *p;
3322     char *sp;
3323 
3324     acquire(&ptable.lock);
3325 
3326     for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
3327         if(p->state == UNUSED)
3328             goto found;
3329 
3330     release(&ptable.lock);
3331     return 0;
3332 
3333 found:
3334     p->state = EMBRYO;
3335     
3336     p->tid = nexttid++ + proc->pid*100;
3337 
3338     release(&ptable.lock);
3339 
3340     
3341     if((p->kstack = kalloc()) == 0){
3342         p->state = UNUSED;
3343         return 0;
3344     }
3345     sp = p->kstack + KSTACKSIZE;
3346 
3347     
3348     sp -= sizeof *p->tf;
3349     p->tf = (struct trapframe*)sp;
3350     
3351     
3352     sp -= 4;
3353     *(uint*)sp = (uint)trapret;
3354 
3355     sp -= sizeof *p->context;
3356     p->context = (struct context*)sp;
3357     memset(p->context, 0, sizeof *p->context);
3358     p->context->eip = (uint)forkret;
3359 
3360     return p;
3361 }
3362 
3363 
3364 int
3365 thread_create(thread_t *thread, void *(*start_routine)(void *), void*arg){
3366 
3367     int i;
3368     uint sz, sp;
3369     struct proc *np;
3370 
3371     
3372     if((np = allocthread()) == 0){
3373         return -1;
3374     }
3375 
3376     np->pid = proc->pid;
3377 
3378     
3379     np->pgdir = proc->pgdir;
3380 
3381     
3382     if(proc->isthread == 1 ){
3383         np->parent = proc->parent;
3384     }else{
3385         np->parent = proc;
3386     }
3387     *np->tf = *proc->tf;
3388 
3389     
3390     np->tf->eax = 0;
3391 
3392     np->tf->eip = (int)(*start_routine);
3393     np->isthread = 1;
3394 
3395 
3396 
3397 
3398 
3399 
3400     acquire(&ptable.lock);
3401     
3402     sz = PGROUNDUP(np->parent->sz);
3403     if((sz = allocuvm(np->parent->pgdir, sz, sz + 2*PGSIZE)) == 0){
3404         goto bad;
3405     }
3406     clearpteu(np->parent->pgdir, (char*)(sz - 2*PGSIZE));
3407     release(&ptable.lock);
3408     sp = sz;
3409     np->parent->sz = sz;
3410     np->sz = sz;
3411     np->stack = sp;
3412 
3413     np->tf->esp = sp;
3414     *((int*)(np->tf->esp - 4)) = (int)arg;
3415     *((int *)(np->tf->esp - 8)) = 0xFFFFFFFF;
3416     np->tf->esp -= 8;
3417 
3418 
3419 
3420     for(i = 0; i < NOFILE; i++)
3421         if(proc->ofile[i])
3422             np->ofile[i] = filedup(proc->ofile[i]);
3423     np->cwd = idup(proc->cwd);
3424 
3425     safestrcpy(np->name, proc->name, sizeof(proc->name));
3426 
3427     
3428     *thread = np->tid;
3429     proc->numOfThread++;
3430     if(proc->stride>0)share_stride_in_proc(proc);
3431 
3432     acquire(&ptable.lock);
3433 
3434     np->state = RUNNABLE;
3435     enqueue(&qOfM[0],np);
3436 
3437     
3438     
3439     
3440     release(&ptable.lock);
3441     yield();
3442 
3443 
3444     return 0;
3445 
3446 bad:
3447     cprintf("thread_create error'\n");
3448 
3449 
3450     return -1;
3451 }
3452 
3453 void
3454 thread_exit(void * retval){
3455 
3456     struct proc *p;
3457     int fd;
3458 
3459 
3460     if(proc == initproc)
3461         panic("init exiting");
3462 
3463     
3464     for(fd = 0; fd < NOFILE; fd++){
3465         if(proc->ofile[fd]){
3466             fileclose(proc->ofile[fd]);
3467             proc->ofile[fd] = 0;
3468         }
3469     }
3470 
3471     begin_op();
3472     iput(proc->cwd);
3473     end_op();
3474     proc->cwd = 0;
3475 
3476     acquire(&ptable.lock);
3477 
3478     
3479     wakeup1((void*)proc->parent);
3480 
3481     
3482     
3483     for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
3484         if(p->parent == proc){
3485             p->parent = initproc;
3486             if(p->state == ZOMBIE){
3487                 wakeup1(initproc);
3488             }
3489         }
3490     }
3491     
3492 
3493     
3494     
3495     if(proc->stride == 0)dequeue(&qOfM[proc->qPosi],proc);
3496     if(proc->pid > 2 )cut_cpu_share(proc->stride);
3497     proc->consumedTime = 0;
3498     proc->stride = 0;
3499     proc->pass = 0;
3500     proc->qPosi = 0;
3501 
3502 
3503     
3504     proc->retval = retval;
3505 
3506     proc->state = ZOMBIE;
3507 
3508     proc->parent->numOfThread--;
3509     if(proc->parent->stride > 0)share_stride_in_proc(proc->parent);
3510 
3511     
3512     
3513     
3514     
3515 
3516     sched();
3517     panic("zombie exit");
3518 }
3519 
3520 int
3521 thread_join(thread_t thread, void **retval){
3522 
3523     struct proc *p;
3524     int havekids;
3525     uint sz;
3526 
3527     acquire(&ptable.lock);
3528     for(;;){
3529         
3530         havekids = 0;
3531         for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
3532             if(p->parent != proc || p->isthread != 1 || p->tid != thread){
3533                 continue;
3534             }
3535             havekids = 1;
3536             if(p->state == ZOMBIE){
3537                 
3538                 
3539                 
3540                 kfree(p->kstack);
3541                 p->kstack = 0;
3542                 p->pid = 0;
3543                 p->tid = 0;
3544                 p->parent = 0;
3545                 p->name[0] = 0;
3546                 p->killed = 0;
3547                 p->state = UNUSED;
3548 
3549 
3550                 
3551                 
3552                 sz = PGROUNDUP(p->sz);
3553                 if((sz = deallocuvm(p->pgdir, sz, sz - 2*PGSIZE)) == 0){
3554                     goto bad;
3555                 }
3556                 empty_stack_clean(proc);
3557 
3558                 
3559                 *retval = p->retval;
3560                 
3561 
3562                 release(&ptable.lock);
3563 
3564                 return 0;
3565             }
3566         }
3567 
3568         
3569         if(!havekids || proc->killed){
3570             cprintf(" [Warning] There isn't child to join \n");
3571             release(&ptable.lock);
3572             return 0;
3573             
3574         }
3575 
3576 
3577 
3578         
3579         sleep((void*)proc, &ptable.lock);  
3580 
3581     }
3582 
3583 bad:
3584     cprintf(" [Error]thread join error\n");
3585     return -1;
3586     return 0;
3587 }
3588 
3589 
3590 
3591 
3592 
3593 
3594 
3595 
3596 
3597 
3598 
3599 
3600 int
3601 thread_clean(thread_t thread, void **retval){
3602 
3603     struct proc *p;
3604     uint sz;
3605     int fd;
3606 
3607     acquire(&ptable.lock);
3608     for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
3609         if(p->isthread != 1 || p->tid != thread){
3610             continue;
3611         }
3612         
3613 
3614         
3615 
3616         if(p == initproc)
3617             panic("init exiting");
3618 
3619         release(&ptable.lock);
3620         
3621         for(fd = 0; fd < NOFILE; fd++){
3622             if(p->ofile[fd]){
3623                 fileclose(p->ofile[fd]);
3624                 p->ofile[fd] = 0;
3625             }
3626         }
3627 
3628         begin_op();
3629         iput(p->cwd);
3630         end_op();
3631         p->cwd = 0;
3632 
3633 
3634         acquire(&ptable.lock);
3635         
3636         wakeup1((void*)p->pid);
3637 
3638 
3639         
3640         if(p->stride == 0)dequeue(&qOfM[p->qPosi],p);
3641         if(p->pid > 2 )cut_cpu_share(p->stride);
3642         p->consumedTime = 0;
3643         p->stride = 0;
3644         p->pass = 0;
3645         p->qPosi = 0;
3646 
3647 
3648         p->retval = retval;
3649 
3650         
3651         proc->parent->numOfThread--;
3652         if(proc->parent->stride > 0)share_stride_in_proc(proc->parent);
3653 
3654         p->state = ZOMBIE;
3655 
3656 
3657         
3658         if(p->kstack)kfree(p->kstack);
3659         p->kstack = 0;
3660         p->pid = 0;
3661         p->parent = 0;
3662         p->name[0] = 0;
3663         p->killed = 0;
3664         p->state = UNUSED;
3665 
3666 
3667         
3668         
3669         sz = PGROUNDUP(p->sz);
3670         if((sz = deallocuvm(p->pgdir, sz, sz - 2*PGSIZE)) == 0){
3671             goto bad;
3672         }
3673         empty_stack_clean(proc);
3674 
3675         
3676         *retval = p->retval;
3677 
3678         release(&ptable.lock);
3679         return 0;
3680     }
3681 
3682     
3683     if(proc->killed){
3684         cprintf(" [Warning] There is no child to clean\n");
3685         release(&ptable.lock);
3686         return 0;
3687         
3688     }
3689 
3690 bad:
3691     cprintf(" [Error]thread clean error\n");
3692     release(&ptable.lock);
3693     return -1;
3694 }
3695 
3696 
3697 
3698 
3699 
3700     void
3701 clean(struct proc *target)
3702 {
3703     proc = target;
3704     switchuvm(target);
3705     target->state = RUNNING;
3706     wakeup(target);
3707     target->context->eip = (uint)exit;
3708     swtch(&proc->context, target->context);
3709 }
3710     int
3711 thread_fork(void)
3712 {
3713     int i, pid;
3714     struct proc *np;
3715     uint tmp_ebp, sz;
3716 
3717     tmp_ebp = proc->parent->tf->ebp;
3718     
3719     if((np = allocproc()) == 0){
3720         return -1;
3721     }
3722 
3723 
3724     
3725     if((np->pgdir = copyuvm_force(proc->pgdir, proc->sz)) == 0){
3726         cprintf("hello??\n");
3727         kfree(np->kstack);
3728         np->kstack = 0;
3729         np->state = UNUSED;
3730         return -1;
3731     }
3732     np->sz = proc->sz;
3733     np->parent = proc;
3734     *np->tf = *proc->tf;
3735 
3736 
3737     
3738     
3739     sz = PGROUNDUP(np->sz)- 2*PGSIZE;
3740     if((sz = deallocuvm(np->pgdir, sz, tmp_ebp)) == 0){
3741         cprintf("new process that forked by thread meets error\n");
3742     }
3743 
3744 
3745     
3746     np->tf->eax = 0;
3747 
3748 
3749 
3750     for(i = 0; i < NOFILE; i++)
3751         if(proc->ofile[i])
3752             np->ofile[i] = filedup(proc->ofile[i]);
3753     np->cwd = idup(proc->cwd);
3754 
3755     safestrcpy(np->name, proc->name, sizeof(proc->name));
3756 
3757     pid = np->pid;
3758 
3759     acquire(&ptable.lock);
3760 
3761     np->state = RUNNABLE;
3762     
3763     enqueue(&qOfM[0],np);
3764 
3765     release(&ptable.lock);
3766 
3767     return pid;
3768 }
3769 
3770 void
3771 share_stride_in_proc(struct proc* parent){
3772     struct proc* p;
3773     ushort real_stride;
3774     ushort each_stride;
3775 
3776     if(parent->stride == 0) return ;
3777 
3778     real_stride = parent->pstride;
3779     each_stride = real_stride*(parent->numOfThread+1);
3780 
3781         findMinPassStride();
3782 
3783     for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
3784         if(p->parent != parent || p->isthread != 1 ){
3785             continue;
3786         }
3787         p->stride = each_stride;
3788         p->pass = minPass;
3789 
3790     }
3791     parent->stride = each_stride;
3792 }
3793 
3794 
3795 
3796 
3797 
3798 
3799 
3800 
3801 
3802 
3803 
3804 
3805 
3806 
3807 .globl swtch
3808 swtch:
3809   movl 4(%esp), %eax
3810   movl 8(%esp), %edx
3811 
3812   
3813   pushl %ebp
3814   pushl %ebx
3815   pushl %esi
3816   pushl %edi
3817 
3818   
3819   movl %esp, (%eax)
3820   movl %edx, %esp
3821 
3822   
3823   popl %edi
3824   popl %esi
3825   popl %ebx
3826   popl %ebp
3827   ret
3828 
3829 
3830 
3831 
3832 
3833 
3834 
3835 
3836 
3837 
3838 
3839 
3840 
3841 
3842 
3843 
3844 
3845 
3846 
3847 
3848 
3849 
3850 
3851 
3852 
3853 
3854 #include "types.h"
3855 #include "defs.h"
3856 #include "param.h"
3857 #include "memlayout.h"
3858 #include "mmu.h"
3859 #include "spinlock.h"
3860 
3861 void freerange(void *vstart, void *vend);
3862 extern char end[]; 
3863 
3864 struct run {
3865   struct run *next;
3866 };
3867 
3868 struct {
3869   struct spinlock lock;
3870   int use_lock;
3871   struct run *freelist;
3872 } kmem;
3873 
3874 
3875 
3876 
3877 
3878 
3879 void
3880 kinit1(void *vstart, void *vend)
3881 {
3882   initlock(&kmem.lock, "kmem");
3883   kmem.use_lock = 0;
3884   freerange(vstart, vend);
3885 }
3886 
3887 void
3888 kinit2(void *vstart, void *vend)
3889 {
3890   freerange(vstart, vend);
3891   kmem.use_lock = 1;
3892 }
3893 
3894 
3895 
3896 
3897 
3898 
3899 
3900 void
3901 freerange(void *vstart, void *vend)
3902 {
3903   char *p;
3904   p = (char*)PGROUNDUP((uint)vstart);
3905   for(; p + PGSIZE <= (char*)vend; p += PGSIZE)
3906     kfree(p);
3907 }
3908 
3909 
3910 
3911 
3912 
3913 
3914 void
3915 kfree(char *v)
3916 {
3917   struct run *r;
3918 
3919   if((uint)v % PGSIZE || v < end || V2P(v) >= PHYSTOP)
3920     panic("kfree");
3921 
3922   
3923   memset(v, 1, PGSIZE);
3924 
3925   if(kmem.use_lock)
3926     acquire(&kmem.lock);
3927   r = (struct run*)v;
3928   r->next = kmem.freelist;
3929   kmem.freelist = r;
3930   if(kmem.use_lock)
3931     release(&kmem.lock);
3932 }
3933 
3934 
3935 
3936 
3937 char*
3938 kalloc(void)
3939 {
3940   struct run *r;
3941 
3942   if(kmem.use_lock)
3943     acquire(&kmem.lock);
3944   r = kmem.freelist;
3945   if(r)
3946     kmem.freelist = r->next;
3947   if(kmem.use_lock)
3948     release(&kmem.lock);
3949   return (char*)r;
3950 }
3951 
3952 
3953 
3954 
3955 
3956 
3957 
3958 
3959 
3960 
3961 
3962 
3963 
3964 
3965 
3966 
3967 
3968 
3969 
3970 
3971 
3972 
3973 
3974 
3975 
3976 
3977 
3978 
3979 
3980 
3981 
3982 
3983 
3984 
3985 
3986 
3987 
3988 
3989 
3990 
3991 
3992 
3993 
3994 
3995 
3996 
3997 
3998 
3999 
4000 
4001 
4002 
4003 #define T_DIVIDE         0      
4004 #define T_DEBUG          1      
4005 #define T_NMI            2      
4006 #define T_BRKPT          3      
4007 #define T_OFLOW          4      
4008 #define T_BOUND          5      
4009 #define T_ILLOP          6      
4010 #define T_DEVICE         7      
4011 #define T_DBLFLT         8      
4012 
4013 #define T_TSS           10      
4014 #define T_SEGNP         11      
4015 #define T_STACK         12      
4016 #define T_GPFLT         13      
4017 #define T_PGFLT         14      
4018 
4019 #define T_FPERR         16      
4020 #define T_ALIGN         17      
4021 #define T_MCHK          18      
4022 #define T_SIMDERR       19      
4023 
4024 
4025 
4026 #define T_SYSCALL       64      
4027 #define T_YIELD         65      
4028 #define T_LAB4         128     
4029 #define T_DEFAULT      500      
4030 
4031 #define T_IRQ0          32      
4032 
4033 #define IRQ_TIMER        0
4034 #define IRQ_KBD          1
4035 #define IRQ_COM1         4
4036 #define IRQ_IDE         14
4037 #define IRQ_ERROR       19
4038 #define IRQ_SPURIOUS    31
4039 
4040 
4041 
4042 
4043 
4044 
4045 
4046 
4047 
4048 
4049 
4050 #!/usr/bin/perl -w
4051 
4052 # Generate vectors.S, the trap/interrupt entry points.
4053 # There has to be one entry point per interrupt number
4054 # since otherwise there's no way for trap() to discover
4055 # the interrupt number.
4056 
4057 print "# generated by vectors.pl - do not edit\n";
4058 print "# handlers\n";
4059 print ".globl alltraps\n";
4060 for(my $i = 0; $i < 256; $i++){
4061     print ".globl vector$i\n";
4062     print "vector$i:\n";
4063     if(!($i == 8 || ($i >= 10 && $i <= 14) || $i == 17)){
4064         print "  pushl \$0\n";
4065     }
4066     print "  pushl \$$i\n";
4067     print "  jmp alltraps\n";
4068 }
4069 
4070 print "\n# vector table\n";
4071 print ".data\n";
4072 print ".globl vectors\n";
4073 print "vectors:\n";
4074 for(my $i = 0; $i < 256; $i++){
4075     print "  .long vector$i\n";
4076 }
4077 
4078 # sample output:
4079 #   # handlers
4080 #   .globl alltraps
4081 #   .globl vector0
4082 #   vector0:
4083 #     pushl $0
4084 #     pushl $0
4085 #     jmp alltraps
4086 #   ...
4087 #
4088 #   # vector table
4089 #   .data
4090 #   .globl vectors
4091 #   vectors:
4092 #     .long vector0
4093 #     .long vector1
4094 #     .long vector2
4095 #   ...
4096 
4097 
4098 
4099 
4100 
4101 
4102   
4103 .globl alltraps
4104 alltraps:
4105   
4106   pushl %ds
4107   pushl %es
4108   pushl %fs
4109   pushl %gs
4110   pushal
4111 
4112   
4113   movw $(SEG_KDATA<<3), %ax
4114   movw %ax, %ds
4115   movw %ax, %es
4116   movw $(SEG_KCPU<<3), %ax
4117   movw %ax, %fs
4118   movw %ax, %gs
4119 
4120   
4121   pushl %esp
4122   call trap
4123   addl $4, %esp
4124 
4125   
4126 .globl trapret
4127 trapret:
4128   popal
4129   popl %gs
4130   popl %fs
4131   popl %es
4132   popl %ds
4133   addl $0x8, %esp  
4134   iret
4135 
4136 
4137 
4138 
4139 
4140 
4141 
4142 
4143 
4144 
4145 
4146 
4147 
4148 
4149 
4150 #include "types.h"
4151 #include "defs.h"
4152 #include "param.h"
4153 #include "memlayout.h"
4154 #include "mmu.h"
4155 #include "x86.h"
4156 #include "traps.h"
4157 #include "proc.h"
4158 #include "mlfq.h"
4159 #include "stride.h"
4160 #include "spinlock.h"
4161 
4162 
4163 struct gatedesc idt[256];
4164 extern uint vectors[];  
4165 struct spinlock tickslock;
4166 uint ticks;
4167 
4168     void
4169 tvinit(void)
4170 {
4171     int i;
4172 
4173     for(i = 0; i < 256; i++)
4174         SETGATE(idt[i], 0, SEG_KCODE<<3, vectors[i], 0);
4175     SETGATE(idt[T_SYSCALL], 1, SEG_KCODE<<3, vectors[T_SYSCALL], DPL_USER);
4176     SETGATE(idt[T_LAB4], 1, SEG_KCODE<<3, vectors[T_LAB4], DPL_USER);
4177 
4178     initlock(&tickslock, "time");
4179 }
4180 
4181     void
4182 idtinit(void)
4183 {
4184     lidt(idt, sizeof(idt));
4185 }
4186 
4187 
4188 
4189 
4190 
4191 
4192 
4193 
4194 
4195 
4196 
4197 
4198 
4199 
4200     void
4201 trap(struct trapframe *tf)
4202 {
4203     if(tf->trapno == T_SYSCALL){
4204         
4205         if(proc->killed){
4206             exit();
4207         }
4208         proc->tf = tf;
4209         syscall();
4210         if(proc->killed)
4211             exit();
4212         return;
4213     }
4214 
4215     if(tf->trapno == T_LAB4){
4216         cprintf("user Interrupt %d called!\n", T_LAB4);
4217         exit();
4218         return;
4219     }
4220 
4221     switch(tf->trapno){
4222         case T_IRQ0 + IRQ_TIMER:
4223             if(cpunum() == 0){
4224                 acquire(&tickslock);
4225                 if(proc != 0){
4226                     proc->consumedTime++;
4227                 }
4228                     
4229                 ticks++;
4230                 wakeup(&ticks);
4231                 release(&tickslock);
4232             }
4233             lapiceoi();
4234             break;
4235         case T_IRQ0 + IRQ_IDE:
4236             ideintr();
4237             lapiceoi();
4238             break;
4239         case T_IRQ0 + IRQ_IDE+1:
4240             
4241             break;
4242         case T_IRQ0 + IRQ_KBD:
4243             kbdintr();
4244             lapiceoi();
4245             break;
4246         case T_IRQ0 + IRQ_COM1:
4247             uartintr();
4248             lapiceoi();
4249             break;
4250         case T_IRQ0 + 7:
4251         case T_IRQ0 + IRQ_SPURIOUS:
4252             cprintf("cpu%d: spurious interrupt at %x:%x\n",
4253                     cpunum(), tf->cs, tf->eip);
4254             lapiceoi();
4255             break;
4256 
4257 
4258         default:
4259             if(proc == 0 || (tf->cs&3) == 0){
4260                 
4261                 cprintf("unexpected trap %d from cpu %d eip %x (cr2=0x%x)\n",
4262                         tf->trapno, cpunum(), tf->eip, rcr2());
4263                 cprintf(" [cause] pid %d / tid %d\n",proc->pid,proc->tid);
4264                 panic("trap");
4265             }
4266             
4267             cprintf("pid %d tid %d %s: trap %d err %d on cpu %d "
4268                     "eip 0x%x addr 0x%x--kill proc\n",
4269                     proc->pid, proc->tid, proc->name, tf->trapno, tf->err, cpunum(), tf->eip,
4270                     rcr2());
4271             proc->killed = 1;
4272     }
4273 
4274     
4275     
4276     
4277     if(proc && proc->killed && (tf->cs&3) == DPL_USER){
4278 
4279         exit();
4280     }
4281 
4282     
4283     
4284     if(proc && proc->state == RUNNING && tf->trapno == T_IRQ0+IRQ_TIMER){
4285         
4286         if(schedulerMode == 1)
4287         {
4288             
4289             if(ticks % MLFQ_BOOST_TIME ==0){
4290                 boostMlfq();
4291                 yieldbytimer = 1; 
4292                 yield();
4293                 
4294             }else if(proc->pid > 2 && proc->state == RUNNING){
4295                 if(proc->consumedTime % qOfM[proc->qPosi].timeAllot == 0){
4296                     if(proc->qPosi != MAX_QUEUE_NUM-1){
4297                         dequeue(&qOfM[proc->qPosi],proc);
4298                         if(proc->qPosi == 2) enqueue(&qOfM[proc->qPosi], proc);
4299                         else enqueue(&qOfM[proc->qPosi+1], proc);
4300                         yieldbytimer = 1;
4301                         yield();
4302                     }
4303 
4304                 }
4305                 
4306                 if(proc->consumedTime % qOfM[proc->qPosi].timeQuan == 0){
4307                     dequeue(&qOfM[proc->qPosi],proc);
4308                     enqueue(&qOfM[proc->qPosi], proc);
4309                     yieldbytimer = 1;
4310                     yield();
4311                 }
4312             }
4313 
4314             
4315         } else if(proc->consumedTime % TIME_PER_ONE_PASS  == 0){
4316             yieldbytimer = 1;
4317             yield();
4318         }
4319     }
4320 
4321     
4322     if(proc && proc->killed && (tf->cs&3) == DPL_USER){
4323         exit();
4324     }
4325 }
4326 
4327 
4328 
4329 
4330 
4331 
4332 
4333 
4334 
4335 
4336 
4337 
4338 
4339 
4340 
4341 
4342 
4343 
4344 
4345 
4346 
4347 
4348 
4349 
4350 
4351 #define SYS_fork    1
4352 #define SYS_exit    2
4353 #define SYS_wait    3
4354 #define SYS_pipe    4
4355 #define SYS_read    5
4356 #define SYS_kill    6
4357 #define SYS_exec    7
4358 #define SYS_fstat   8
4359 #define SYS_chdir   9
4360 #define SYS_dup    10
4361 #define SYS_getpid 11
4362 #define SYS_getppid 12
4363 #define SYS_sbrk   13
4364 #define SYS_sleep  14
4365 #define SYS_uptime 15
4366 #define SYS_open   16
4367 #define SYS_write  17
4368 #define SYS_mknod  18
4369 #define SYS_unlink 19
4370 #define SYS_link   20
4371 #define SYS_mkdir  21
4372 #define SYS_close  22
4373 #define SYS_my_syscall 23
4374 #define SYS_yield   24
4375 #define SYS_getlev 25
4376 #define SYS_set_cpu_share 26
4377 #define SYS_thread_create 27
4378 #define SYS_thread_exit 28
4379 #define SYS_thread_join 29
4380 
4381 
4382 
4383 
4384 
4385 
4386 
4387 
4388 
4389 
4390 
4391 
4392 
4393 
4394 
4395 
4396 
4397 
4398 
4399 
4400 #include "types.h"
4401 #include "defs.h"
4402 #include "param.h"
4403 #include "memlayout.h"
4404 #include "mmu.h"
4405 #include "proc.h"
4406 #include "x86.h"
4407 #include "syscall.h"
4408 
4409 
4410 
4411 
4412 
4413 
4414 
4415 
4416 int
4417 fetchint(uint addr, int *ip)
4418 {
4419   if(addr >= proc->sz || addr+4 > proc->sz)
4420     return -1;
4421   *ip = *(int*)(addr);
4422   return 0;
4423 }
4424 
4425 
4426 
4427 
4428 int
4429 fetchstr(uint addr, char **pp)
4430 {
4431   char *s, *ep;
4432 
4433   if(addr >= proc->sz)
4434     return -1;
4435   *pp = (char*)addr;
4436   ep = (char*)proc->sz;
4437   for(s = *pp; s < ep; s++)
4438     if(*s == 0)
4439       return s - *pp;
4440   return -1;
4441 }
4442 
4443 
4444 int
4445 argint(int n, int *ip)
4446 {
4447   return fetchint(proc->tf->esp + 4 + 4*n, ip);
4448 }
4449 
4450 
4451 
4452 
4453 int
4454 argptr(int n, char **pp, int size)
4455 {
4456   int i;
4457 
4458   if(argint(n, &i) < 0)
4459     return -1;
4460   if(size < 0 || (uint)i >= proc->sz || (uint)i+size > proc->sz)
4461     return -1;
4462   *pp = (char*)i;
4463   return 0;
4464 }
4465 
4466 
4467 
4468 
4469 
4470 int
4471 argstr(int n, char **pp)
4472 {
4473   int addr;
4474   if(argint(n, &addr) < 0)
4475     return -1;
4476   return fetchstr(addr, pp);
4477 }
4478 
4479 extern int sys_chdir(void);
4480 extern int sys_close(void);
4481 extern int sys_dup(void);
4482 extern int sys_exec(void);
4483 extern int sys_exit(void);
4484 extern int sys_fork(void);
4485 extern int sys_fstat(void);
4486 extern int sys_getpid(void);
4487 extern int sys_getppid(void);
4488 extern int sys_kill(void);
4489 extern int sys_link(void);
4490 extern int sys_mkdir(void);
4491 extern int sys_mknod(void);
4492 extern int sys_open(void);
4493 extern int sys_pipe(void);
4494 extern int sys_read(void);
4495 extern int sys_sbrk(void);
4496 extern int sys_sleep(void);
4497 extern int sys_unlink(void);
4498 extern int sys_wait(void);
4499 extern int sys_write(void);
4500 extern int sys_uptime(void);
4501 extern int sys_my_syscall(void);
4502 extern int sys_yield(void);
4503 extern int sys_getlev(void);
4504 extern int sys_set_cpu_share(void);
4505 extern int sys_thread_create(void);
4506 extern int sys_thread_exit(void);
4507 extern int sys_thread_join(void);
4508 
4509 
4510 static int (*syscalls[])(void) = {
4511 [SYS_fork]    sys_fork,
4512 [SYS_exit]    sys_exit,
4513 [SYS_wait]    sys_wait,
4514 [SYS_pipe]    sys_pipe,
4515 [SYS_read]    sys_read,
4516 [SYS_kill]    sys_kill,
4517 [SYS_exec]    sys_exec,
4518 [SYS_fstat]   sys_fstat,
4519 [SYS_chdir]   sys_chdir,
4520 [SYS_dup]     sys_dup,
4521 [SYS_getpid]  sys_getpid,
4522 [SYS_getppid]  sys_getppid,
4523 [SYS_sbrk]    sys_sbrk,
4524 [SYS_sleep]   sys_sleep,
4525 [SYS_uptime]  sys_uptime,
4526 [SYS_open]    sys_open,
4527 [SYS_write]   sys_write,
4528 [SYS_mknod]   sys_mknod,
4529 [SYS_unlink]  sys_unlink,
4530 [SYS_link]    sys_link,
4531 [SYS_mkdir]   sys_mkdir,
4532 [SYS_close]   sys_close,
4533 [SYS_my_syscall] sys_my_syscall,
4534 [SYS_yield] sys_yield,
4535 [SYS_getlev] sys_getlev,
4536 [SYS_set_cpu_share] sys_set_cpu_share,
4537 [SYS_thread_create] sys_thread_create,
4538 [SYS_thread_exit] sys_thread_exit,
4539 [SYS_thread_join] sys_thread_join,
4540 };
4541 
4542 
4543 
4544 
4545 
4546 
4547 
4548 
4549 
4550 void
4551 syscall(void)
4552 {
4553   int num;
4554 
4555   num = proc->tf->eax;
4556   if(num > 0 && num < NELEM(syscalls) && syscalls[num]) {
4557     proc->tf->eax = syscalls[num]();
4558   } else {
4559     cprintf("%d %s: unknown sys call %d\n",
4560             proc->pid, proc->name, num);
4561     proc->tf->eax = -1;
4562   }
4563 }
4564 
4565 
4566 
4567 
4568 
4569 
4570 
4571 
4572 
4573 
4574 
4575 
4576 
4577 
4578 
4579 
4580 
4581 
4582 
4583 
4584 
4585 
4586 
4587 
4588 
4589 
4590 
4591 
4592 
4593 
4594 
4595 
4596 
4597 
4598 
4599 
4600 #include "types.h"
4601 #include "x86.h"
4602 #include "defs.h"
4603 #include "date.h"
4604 #include "param.h"
4605 #include "memlayout.h"
4606 #include "mmu.h"
4607 #include "proc.h"
4608 #include "mlfq.h"
4609 #include "stride.h"
4610 
4611 int
4612 sys_fork(void)
4613 {
4614   return fork();
4615 }
4616 
4617 int
4618 sys_exit(void)
4619 {
4620   exit();
4621   return 0;  
4622 }
4623 
4624 int
4625 sys_wait(void)
4626 {
4627   return wait();
4628 }
4629 
4630 int
4631 sys_kill(void)
4632 {
4633   int pid;
4634 
4635   if(argint(0, &pid) < 0)
4636     return -1;
4637   return kill(pid);
4638 }
4639 
4640 int
4641 sys_getpid(void)
4642 {
4643   return proc->pid;
4644 }
4645 
4646 
4647 
4648 
4649 
4650 int
4651 sys_getppid(void)
4652 {
4653     return proc->parent->pid;
4654 }
4655 
4656 void
4657 sys_yield(void)
4658 {
4659     return yield();
4660 }
4661 int
4662 sys_getlev(void)
4663 {
4664     return curQ;
4665 }
4666 int
4667 sys_set_cpu_share(void)
4668 {
4669     int share;
4670     if(argint(0, &share) < 0)
4671         return -1;
4672     return set_cpu_share(share);
4673 }
4674 int
4675 sys_sbrk(void)
4676 {
4677   int addr;
4678   int n;
4679 
4680   if(argint(0, &n) < 0)
4681     return -1;
4682  
4683   if(proc->isthread == 1){
4684       proc->sz = proc->parent->sz;
4685   }
4686   addr = proc->sz;
4687 
4688   if(growproc(n) < 0)
4689     return -1;
4690   return addr;
4691 }
4692 
4693 
4694 
4695 
4696 
4697 
4698 
4699 
4700 int
4701 sys_sleep(void)
4702 {
4703   int n;
4704   uint ticks0;
4705 
4706   if(argint(0, &n) < 0)
4707     return -1;
4708   acquire(&tickslock);
4709   ticks0 = ticks;
4710   while(ticks - ticks0 < n){
4711     if(proc->killed){
4712       release(&tickslock);
4713       return -1;
4714     }
4715     sleep(&ticks, &tickslock);
4716   }
4717   release(&tickslock);
4718   return 0;
4719 }
4720 
4721 
4722 
4723 int
4724 sys_uptime(void)
4725 {
4726   uint xticks;
4727 
4728   acquire(&tickslock);
4729   xticks = ticks;
4730   release(&tickslock);
4731   return xticks;
4732 }
4733 
4734 int
4735 sys_thread_create(void)
4736 {
4737     int thread;
4738     int addrOfStartRoutine;
4739     int arg;
4740 
4741     if(argint(0, &thread) < 0)
4742         return -1;
4743     if(argint(1, &addrOfStartRoutine) < 0)
4744         return -1;
4745     if(argint(2, &arg) < 0)
4746         return -1;
4747 
4748     return thread_create((thread_t *)thread, (void*)addrOfStartRoutine,(void*)arg);
4749 
4750 }
4751 
4752 void
4753 sys_thread_exit(void)
4754 {
4755     int retval;
4756 
4757     if(argint(0, &retval) < 0){
4758     }
4759 
4760     return thread_exit((void*)retval);
4761 }
4762 
4763 int
4764 sys_thread_join(void)
4765 {
4766     int thread;
4767     int retval;
4768 
4769     if(argint(0, &thread) < 0)
4770         return -1;
4771     if(argint(1, &retval) < 0)
4772         return -1;
4773     return thread_join((thread_t)thread, (void**)retval);
4774 }
4775 
4776 
4777 
4778 
4779 
4780 
4781 
4782 
4783 
4784 
4785 
4786 
4787 
4788 
4789 
4790 
4791 
4792 
4793 
4794 
4795 
4796 
4797 
4798 
4799 
4800 struct buf {
4801   int flags;
4802   uint dev;
4803   uint blockno;
4804   struct sleeplock lock;
4805   uint refcnt;
4806   struct buf *prev; 
4807   struct buf *next;
4808   struct buf *qnext; 
4809   uchar data[BSIZE];
4810 };
4811 #define B_VALID 0x2  
4812 #define B_DIRTY 0x4  
4813 
4814 
4815 
4816 
4817 
4818 
4819 
4820 
4821 
4822 
4823 
4824 
4825 
4826 
4827 
4828 
4829 
4830 
4831 
4832 
4833 
4834 
4835 
4836 
4837 
4838 
4839 
4840 
4841 
4842 
4843 
4844 
4845 
4846 
4847 
4848 
4849 
4850 
4851 struct sleeplock {
4852   uint locked;       
4853   struct spinlock lk; 
4854 
4855   
4856   char *name;        
4857   int pid;           
4858 };
4859 
4860 
4861 
4862 
4863 
4864 
4865 
4866 
4867 
4868 
4869 
4870 
4871 
4872 
4873 
4874 
4875 
4876 
4877 
4878 
4879 
4880 
4881 
4882 
4883 
4884 
4885 
4886 
4887 
4888 
4889 
4890 
4891 
4892 
4893 
4894 
4895 
4896 
4897 
4898 
4899 
4900 #define O_RDONLY  0x000
4901 #define O_WRONLY  0x001
4902 #define O_RDWR    0x002
4903 #define O_CREATE  0x200
4904 
4905 
4906 
4907 
4908 
4909 
4910 
4911 
4912 
4913 
4914 
4915 
4916 
4917 
4918 
4919 
4920 
4921 
4922 
4923 
4924 
4925 
4926 
4927 
4928 
4929 
4930 
4931 
4932 
4933 
4934 
4935 
4936 
4937 
4938 
4939 
4940 
4941 
4942 
4943 
4944 
4945 
4946 
4947 
4948 
4949 
4950 #define T_DIR  1   
4951 #define T_FILE 2   
4952 #define T_DEV  3   
4953 
4954 struct stat {
4955   short type;  
4956   int dev;     
4957   uint ino;    
4958   short nlink; 
4959   uint size;   
4960 };
4961 
4962 
4963 
4964 
4965 
4966 
4967 
4968 
4969 
4970 
4971 
4972 
4973 
4974 
4975 
4976 
4977 
4978 
4979 
4980 
4981 
4982 
4983 
4984 
4985 
4986 
4987 
4988 
4989 
4990 
4991 
4992 
4993 
4994 
4995 
4996 
4997 
4998 
4999 
5000 
5001 
5002 
5003 
5004 #define ROOTINO 1  
5005 #define BSIZE 512  
5006 
5007 
5008 
5009 
5010 
5011 
5012 
5013 struct superblock {
5014   uint size;         
5015   uint nblocks;      
5016   uint ninodes;      
5017   uint nlog;         
5018   uint logstart;     
5019   uint inodestart;   
5020   uint bmapstart;    
5021 };
5022 
5023 #define NDIRECT 12
5024 #define NINDIRECT (BSIZE / sizeof(uint))
5025 #define MAXFILE (NDIRECT + NINDIRECT)
5026 
5027 
5028 struct dinode {
5029   short type;           
5030   short major;          
5031   short minor;          
5032   short nlink;          
5033   uint size;            
5034   uint addrs[NDIRECT+1];   
5035 };
5036 
5037 
5038 
5039 
5040 
5041 
5042 
5043 
5044 
5045 
5046 
5047 
5048 
5049 
5050 
5051 #define IPB           (BSIZE / sizeof(struct dinode))
5052 
5053 
5054 #define IBLOCK(i, sb)     ((i) / IPB + sb.inodestart)
5055 
5056 
5057 #define BPB           (BSIZE*8)
5058 
5059 
5060 #define BBLOCK(b, sb) (b/BPB + sb.bmapstart)
5061 
5062 
5063 #define DIRSIZ 14
5064 
5065 struct dirent {
5066   ushort inum;
5067   char name[DIRSIZ];
5068 };
5069 
5070 
5071 
5072 
5073 
5074 
5075 
5076 
5077 
5078 
5079 
5080 
5081 
5082 
5083 
5084 
5085 
5086 
5087 
5088 
5089 
5090 
5091 
5092 
5093 
5094 
5095 
5096 
5097 
5098 
5099 
5100 struct file {
5101   enum { FD_NONE, FD_PIPE, FD_INODE } type;
5102   int ref; 
5103   char readable;
5104   char writable;
5105   struct pipe *pipe;
5106   struct inode *ip;
5107   uint off;
5108 };
5109 
5110 
5111 
5112 struct inode {
5113   uint dev;           
5114   uint inum;          
5115   int ref;            
5116   struct sleeplock lock;
5117   int flags;          
5118 
5119   short type;         
5120   short major;
5121   short minor;
5122   short nlink;
5123   uint size;
5124   uint addrs[NDIRECT+1];
5125 };
5126 #define I_VALID 0x2
5127 
5128 
5129 
5130 struct devsw {
5131   int (*read)(struct inode*, char*, int);
5132   int (*write)(struct inode*, char*, int);
5133 };
5134 
5135 extern struct devsw devsw[];
5136 
5137 #define CONSOLE 1
5138 
5139 
5140 
5141 
5142 
5143 
5144 
5145 
5146 
5147 
5148 
5149 
5150 
5151 
5152 
5153 
5154 
5155 
5156 
5157 
5158 
5159 
5160 
5161 
5162 
5163 
5164 
5165 
5166 
5167 
5168 
5169 
5170 
5171 
5172 
5173 
5174 
5175 
5176 
5177 
5178 
5179 
5180 
5181 
5182 
5183 
5184 
5185 
5186 
5187 
5188 
5189 
5190 
5191 
5192 
5193 
5194 
5195 
5196 
5197 
5198 
5199 
5200 
5201 
5202 #include "types.h"
5203 #include "defs.h"
5204 #include "param.h"
5205 #include "memlayout.h"
5206 #include "mmu.h"
5207 #include "proc.h"
5208 #include "x86.h"
5209 #include "traps.h"
5210 #include "spinlock.h"
5211 #include "sleeplock.h"
5212 #include "fs.h"
5213 #include "buf.h"
5214 
5215 #define SECTOR_SIZE   512
5216 #define IDE_BSY       0x80
5217 #define IDE_DRDY      0x40
5218 #define IDE_DF        0x20
5219 #define IDE_ERR       0x01
5220 
5221 #define IDE_CMD_READ  0x20
5222 #define IDE_CMD_WRITE 0x30
5223 #define IDE_CMD_RDMUL 0xc4
5224 #define IDE_CMD_WRMUL 0xc5
5225 
5226 
5227 
5228 
5229 
5230 static struct spinlock idelock;
5231 static struct buf *idequeue;
5232 
5233 static int havedisk1;
5234 static void idestart(struct buf*);
5235 
5236 
5237 static int
5238 idewait(int checkerr)
5239 {
5240   int r;
5241 
5242   while(((r = inb(0x1f7)) & (IDE_BSY|IDE_DRDY)) != IDE_DRDY)
5243     ;
5244   if(checkerr && (r & (IDE_DF|IDE_ERR)) != 0)
5245     return -1;
5246   return 0;
5247 }
5248 
5249 
5250 void
5251 ideinit(void)
5252 {
5253   int i;
5254 
5255   initlock(&idelock, "ide");
5256   picenable(IRQ_IDE);
5257   ioapicenable(IRQ_IDE, ncpu - 1);
5258   idewait(0);
5259 
5260   
5261   outb(0x1f6, 0xe0 | (1<<4));
5262   for(i=0; i<1000; i++){
5263     if(inb(0x1f7) != 0){
5264       havedisk1 = 1;
5265       break;
5266     }
5267   }
5268 
5269   
5270   outb(0x1f6, 0xe0 | (0<<4));
5271 }
5272 
5273 
5274 static void
5275 idestart(struct buf *b)
5276 {
5277   if(b == 0)
5278     panic("idestart");
5279   if(b->blockno >= FSSIZE)
5280     panic("incorrect blockno");
5281   int sector_per_block =  BSIZE/SECTOR_SIZE;
5282   int sector = b->blockno * sector_per_block;
5283   int read_cmd = (sector_per_block == 1) ? IDE_CMD_READ :  IDE_CMD_RDMUL;
5284   int write_cmd = (sector_per_block == 1) ? IDE_CMD_WRITE : IDE_CMD_WRMUL;
5285 
5286   if (sector_per_block > 7) panic("idestart");
5287 
5288   idewait(0);
5289   outb(0x3f6, 0);  
5290   outb(0x1f2, sector_per_block);  
5291   outb(0x1f3, sector & 0xff);
5292   outb(0x1f4, (sector >> 8) & 0xff);
5293   outb(0x1f5, (sector >> 16) & 0xff);
5294   outb(0x1f6, 0xe0 | ((b->dev&1)<<4) | ((sector>>24)&0x0f));
5295   if(b->flags & B_DIRTY){
5296     outb(0x1f7, write_cmd);
5297     outsl(0x1f0, b->data, BSIZE/4);
5298   } else {
5299     outb(0x1f7, read_cmd);
5300   }
5301 }
5302 
5303 
5304 void
5305 ideintr(void)
5306 {
5307   struct buf *b;
5308 
5309   
5310   acquire(&idelock);
5311   if((b = idequeue) == 0){
5312     release(&idelock);
5313     
5314     return;
5315   }
5316   idequeue = b->qnext;
5317 
5318   
5319   if(!(b->flags & B_DIRTY) && idewait(1) >= 0)
5320     insl(0x1f0, b->data, BSIZE/4);
5321 
5322   
5323   b->flags |= B_VALID;
5324   b->flags &= ~B_DIRTY;
5325   wakeup(b);
5326 
5327   
5328   if(idequeue != 0)
5329     idestart(idequeue);
5330 
5331   release(&idelock);
5332 }
5333 
5334 
5335 
5336 
5337 
5338 
5339 
5340 
5341 
5342 
5343 
5344 
5345 
5346 
5347 
5348 
5349 
5350 
5351 
5352 
5353 void
5354 iderw(struct buf *b)
5355 {
5356   struct buf **pp;
5357 
5358   if(!holdingsleep(&b->lock))
5359     panic("iderw: buf not locked");
5360   if((b->flags & (B_VALID|B_DIRTY)) == B_VALID)
5361     panic("iderw: nothing to do");
5362   if(b->dev != 0 && !havedisk1)
5363     panic("iderw: ide disk 1 not present");
5364 
5365   acquire(&idelock);  
5366 
5367   
5368   b->qnext = 0;
5369   for(pp=&idequeue; *pp; pp=&(*pp)->qnext)  
5370     ;
5371   *pp = b;
5372 
5373   
5374   if(idequeue == b)
5375     idestart(b);
5376 
5377   
5378   while((b->flags & (B_VALID|B_DIRTY)) != B_VALID){
5379     sleep(b, &idelock);
5380   }
5381 
5382   release(&idelock);
5383 }
5384 
5385 
5386 
5387 
5388 
5389 
5390 
5391 
5392 
5393 
5394 
5395 
5396 
5397 
5398 
5399 
5400 
5401 
5402 
5403 
5404 
5405 
5406 
5407 
5408 
5409 
5410 
5411 
5412 
5413 
5414 
5415 
5416 
5417 
5418 
5419 
5420 #include "types.h"
5421 #include "defs.h"
5422 #include "param.h"
5423 #include "spinlock.h"
5424 #include "sleeplock.h"
5425 #include "fs.h"
5426 #include "buf.h"
5427 
5428 struct {
5429   struct spinlock lock;
5430   struct buf buf[NBUF];
5431 
5432   
5433   
5434   struct buf head;
5435 } bcache;
5436 
5437 void
5438 binit(void)
5439 {
5440   struct buf *b;
5441 
5442   initlock(&bcache.lock, "bcache");
5443 
5444 
5445 
5446 
5447 
5448 
5449 
5450   
5451   bcache.head.prev = &bcache.head;
5452   bcache.head.next = &bcache.head;
5453   for(b = bcache.buf; b < bcache.buf+NBUF; b++){
5454     b->next = bcache.head.next;
5455     b->prev = &bcache.head;
5456     initsleeplock(&b->lock, "buffer");
5457     bcache.head.next->prev = b;
5458     bcache.head.next = b;
5459   }
5460 }
5461 
5462 
5463 
5464 
5465 static struct buf*
5466 bget(uint dev, uint blockno)
5467 {
5468   struct buf *b;
5469 
5470   acquire(&bcache.lock);
5471 
5472   
5473   for(b = bcache.head.next; b != &bcache.head; b = b->next){
5474     if(b->dev == dev && b->blockno == blockno){
5475       b->refcnt++;
5476       release(&bcache.lock);
5477       acquiresleep(&b->lock);
5478       return b;
5479     }
5480   }
5481 
5482   
5483   
5484   
5485   for(b = bcache.head.prev; b != &bcache.head; b = b->prev){
5486     if(b->refcnt == 0 && (b->flags & B_DIRTY) == 0) {
5487       b->dev = dev;
5488       b->blockno = blockno;
5489       b->flags = 0;
5490       b->refcnt = 1;
5491       release(&bcache.lock);
5492       acquiresleep(&b->lock);
5493       return b;
5494     }
5495   }
5496   panic("bget: no buffers");
5497 }
5498 
5499 
5500 
5501 struct buf*
5502 bread(uint dev, uint blockno)
5503 {
5504   struct buf *b;
5505 
5506   b = bget(dev, blockno);
5507   if(!(b->flags & B_VALID)) {
5508     iderw(b);
5509   }
5510   return b;
5511 }
5512 
5513 
5514 void
5515 bwrite(struct buf *b)
5516 {
5517   if(!holdingsleep(&b->lock))
5518     panic("bwrite");
5519   b->flags |= B_DIRTY;
5520   iderw(b);
5521 }
5522 
5523 
5524 
5525 void
5526 brelse(struct buf *b)
5527 {
5528   if(!holdingsleep(&b->lock))
5529     panic("brelse");
5530 
5531   releasesleep(&b->lock);
5532 
5533   acquire(&bcache.lock);
5534   b->refcnt--;
5535   if (b->refcnt == 0) {
5536     
5537     b->next->prev = b->prev;
5538     b->prev->next = b->next;
5539     b->next = bcache.head.next;
5540     b->prev = &bcache.head;
5541     bcache.head.next->prev = b;
5542     bcache.head.next = b;
5543   }
5544 
5545   release(&bcache.lock);
5546 }
5547 
5548 
5549 
5550 
5551 
5552 
5553 
5554 
5555 
5556 
5557 
5558 
5559 
5560 
5561 
5562 
5563 
5564 
5565 
5566 
5567 
5568 
5569 
5570 
5571 
5572 
5573 
5574 
5575 
5576 
5577 
5578 
5579 
5580 
5581 
5582 
5583 
5584 
5585 
5586 
5587 
5588 
5589 
5590 
5591 
5592 
5593 
5594 
5595 
5596 
5597 
5598 
5599 
5600 
5601 
5602 #include "types.h"
5603 #include "defs.h"
5604 #include "param.h"
5605 #include "x86.h"
5606 #include "memlayout.h"
5607 #include "mmu.h"
5608 #include "proc.h"
5609 #include "spinlock.h"
5610 #include "sleeplock.h"
5611 
5612 void
5613 initsleeplock(struct sleeplock *lk, char *name)
5614 {
5615   initlock(&lk->lk, "sleep lock");
5616   lk->name = name;
5617   lk->locked = 0;
5618   lk->pid = 0;
5619 }
5620 
5621 void
5622 acquiresleep(struct sleeplock *lk)
5623 {
5624   acquire(&lk->lk);
5625   while (lk->locked) {
5626     sleep(lk, &lk->lk);
5627   }
5628   lk->locked = 1;
5629   lk->pid = proc->pid;
5630   release(&lk->lk);
5631 }
5632 
5633 void
5634 releasesleep(struct sleeplock *lk)
5635 {
5636   acquire(&lk->lk);
5637   lk->locked = 0;
5638   lk->pid = 0;
5639   wakeup(lk);
5640   release(&lk->lk);
5641 }
5642 
5643 
5644 
5645 
5646 
5647 
5648 
5649 
5650 int
5651 holdingsleep(struct sleeplock *lk)
5652 {
5653   int r;
5654 
5655   acquire(&lk->lk);
5656   r = lk->locked;
5657   release(&lk->lk);
5658   return r;
5659 }
5660 
5661 
5662 
5663 
5664 
5665 
5666 
5667 
5668 
5669 
5670 
5671 
5672 
5673 
5674 
5675 
5676 
5677 
5678 
5679 
5680 
5681 
5682 
5683 
5684 
5685 
5686 
5687 
5688 
5689 
5690 
5691 
5692 
5693 
5694 
5695 
5696 
5697 
5698 
5699 
5700 #include "types.h"
5701 #include "defs.h"
5702 #include "param.h"
5703 #include "spinlock.h"
5704 #include "sleeplock.h"
5705 #include "fs.h"
5706 #include "buf.h"
5707 
5708 
5709 
5710 
5711 
5712 
5713 
5714 
5715 
5716 
5717 
5718 
5719 
5720 
5721 
5722 
5723 
5724 
5725 
5726 
5727 
5728 
5729 
5730 
5731 
5732 
5733 struct logheader {
5734   int n;
5735   int block[LOGSIZE];
5736 };
5737 
5738 struct log {
5739   struct spinlock lock;
5740   int start;
5741   int size;
5742   int outstanding; 
5743   int committing;  
5744   int dev;
5745   struct logheader lh;
5746 };
5747 
5748 
5749 
5750 struct log log;
5751 
5752 static void recover_from_log(void);
5753 static void commit();
5754 
5755 void
5756 initlog(int dev)
5757 {
5758   if (sizeof(struct logheader) >= BSIZE)
5759     panic("initlog: too big logheader");
5760 
5761   struct superblock sb;
5762   initlock(&log.lock, "log");
5763   readsb(dev, &sb);
5764   log.start = sb.logstart;
5765   log.size = sb.nlog;
5766   log.dev = dev;
5767   recover_from_log();
5768 }
5769 
5770 
5771 static void
5772 install_trans(void)
5773 {
5774   int tail;
5775 
5776   for (tail = 0; tail < log.lh.n; tail++) {
5777     struct buf *lbuf = bread(log.dev, log.start+tail+1); 
5778     struct buf *dbuf = bread(log.dev, log.lh.block[tail]); 
5779     memmove(dbuf->data, lbuf->data, BSIZE);  
5780     bwrite(dbuf);  
5781     brelse(lbuf);
5782     brelse(dbuf);
5783   }
5784 }
5785 
5786 
5787 static void
5788 read_head(void)
5789 {
5790   struct buf *buf = bread(log.dev, log.start);
5791   struct logheader *lh = (struct logheader *) (buf->data);
5792   int i;
5793   log.lh.n = lh->n;
5794   for (i = 0; i < log.lh.n; i++) {
5795     log.lh.block[i] = lh->block[i];
5796   }
5797   brelse(buf);
5798 }
5799 
5800 
5801 
5802 
5803 static void
5804 write_head(void)
5805 {
5806   struct buf *buf = bread(log.dev, log.start);
5807   struct logheader *hb = (struct logheader *) (buf->data);
5808   int i;
5809   hb->n = log.lh.n;
5810   for (i = 0; i < log.lh.n; i++) {
5811     hb->block[i] = log.lh.block[i];
5812   }
5813   bwrite(buf);
5814   brelse(buf);
5815 }
5816 
5817 static void
5818 recover_from_log(void)
5819 {
5820   read_head();
5821   install_trans(); 
5822   log.lh.n = 0;
5823   write_head(); 
5824 }
5825 
5826 
5827 void
5828 begin_op(void)
5829 {
5830   acquire(&log.lock);
5831   while(1){
5832     if(log.committing){
5833       sleep(&log, &log.lock);
5834     } else if(log.lh.n + (log.outstanding+1)*MAXOPBLOCKS > LOGSIZE){
5835       
5836       sleep(&log, &log.lock);
5837     } else {
5838       log.outstanding += 1;
5839       release(&log.lock);
5840       break;
5841     }
5842   }
5843 }
5844 
5845 
5846 
5847 
5848 
5849 
5850 
5851 
5852 void
5853 end_op(void)
5854 {
5855   int do_commit = 0;
5856 
5857   acquire(&log.lock);
5858   log.outstanding -= 1;
5859   if(log.committing)
5860     panic("log.committing");
5861   if(log.outstanding == 0){
5862     do_commit = 1;
5863     log.committing = 1;
5864   } else {
5865     
5866     wakeup(&log);
5867   }
5868   release(&log.lock);
5869 
5870   if(do_commit){
5871     
5872     
5873     commit();
5874     acquire(&log.lock);
5875     log.committing = 0;
5876     wakeup(&log);
5877     release(&log.lock);
5878   }
5879 }
5880 
5881 
5882 static void
5883 write_log(void)
5884 {
5885   int tail;
5886 
5887   for (tail = 0; tail < log.lh.n; tail++) {
5888     struct buf *to = bread(log.dev, log.start+tail+1); 
5889     struct buf *from = bread(log.dev, log.lh.block[tail]); 
5890     memmove(to->data, from->data, BSIZE);
5891     bwrite(to);  
5892     brelse(from);
5893     brelse(to);
5894   }
5895 }
5896 
5897 
5898 
5899 
5900 static void
5901 commit()
5902 {
5903   if (log.lh.n > 0) {
5904     write_log();     
5905     write_head();    
5906     install_trans(); 
5907     log.lh.n = 0;
5908     write_head();    
5909   }
5910 }
5911 
5912 
5913 
5914 
5915 
5916 
5917 
5918 
5919 
5920 
5921 void
5922 log_write(struct buf *b)
5923 {
5924   int i;
5925 
5926   if (log.lh.n >= LOGSIZE || log.lh.n >= log.size - 1)
5927     panic("too big a transaction");
5928   if (log.outstanding < 1)
5929     panic("log_write outside of trans");
5930 
5931   acquire(&log.lock);
5932   for (i = 0; i < log.lh.n; i++) {
5933     if (log.lh.block[i] == b->blockno)   
5934       break;
5935   }
5936   log.lh.block[i] = b->blockno;
5937   if (i == log.lh.n)
5938     log.lh.n++;
5939   b->flags |= B_DIRTY; 
5940   release(&log.lock);
5941 }
5942 
5943 
5944 
5945 
5946 
5947 
5948 
5949 
5950 
5951 
5952 
5953 
5954 
5955 
5956 
5957 
5958 
5959 
5960 
5961 #include "types.h"
5962 #include "defs.h"
5963 #include "param.h"
5964 #include "stat.h"
5965 #include "mmu.h"
5966 #include "proc.h"
5967 #include "spinlock.h"
5968 #include "sleeplock.h"
5969 #include "fs.h"
5970 #include "buf.h"
5971 #include "file.h"
5972 
5973 #define min(a, b) ((a) < (b) ? (a) : (b))
5974 static void itrunc(struct inode*);
5975 
5976 
5977 struct superblock sb;
5978 
5979 
5980 void
5981 readsb(int dev, struct superblock *sb)
5982 {
5983   struct buf *bp;
5984 
5985   bp = bread(dev, 1);
5986   memmove(sb, bp->data, sizeof(*sb));
5987   brelse(bp);
5988 }
5989 
5990 
5991 
5992 
5993 
5994 
5995 
5996 
5997 
5998 
5999 
6000 
6001 static void
6002 bzero(int dev, int bno)
6003 {
6004   struct buf *bp;
6005 
6006   bp = bread(dev, bno);
6007   memset(bp->data, 0, BSIZE);
6008   log_write(bp);
6009   brelse(bp);
6010 }
6011 
6012 
6013 
6014 
6015 static uint
6016 balloc(uint dev)
6017 {
6018   int b, bi, m;
6019   struct buf *bp;
6020 
6021   bp = 0;
6022   for(b = 0; b < sb.size; b += BPB){
6023     bp = bread(dev, BBLOCK(b, sb));
6024     for(bi = 0; bi < BPB && b + bi < sb.size; bi++){
6025       m = 1 << (bi % 8);
6026       if((bp->data[bi/8] & m) == 0){  
6027         bp->data[bi/8] |= m;  
6028         log_write(bp);
6029         brelse(bp);
6030         bzero(dev, b + bi);
6031         return b + bi;
6032       }
6033     }
6034     brelse(bp);
6035   }
6036   panic("balloc: out of blocks");
6037 }
6038 
6039 
6040 
6041 
6042 
6043 
6044 
6045 
6046 
6047 
6048 
6049 
6050 
6051 static void
6052 bfree(int dev, uint b)
6053 {
6054   struct buf *bp;
6055   int bi, m;
6056 
6057   readsb(dev, &sb);
6058   bp = bread(dev, BBLOCK(b, sb));
6059   bi = b % BPB;
6060   m = 1 << (bi % 8);
6061   if((bp->data[bi/8] & m) == 0)
6062     panic("freeing free block");
6063   bp->data[bi/8] &= ~m;
6064   log_write(bp);
6065   brelse(bp);
6066 }
6067 
6068 
6069 
6070 
6071 
6072 
6073 
6074 
6075 
6076 
6077 
6078 
6079 
6080 
6081 
6082 
6083 
6084 
6085 
6086 
6087 
6088 
6089 
6090 
6091 
6092 
6093 
6094 
6095 
6096 
6097 
6098 
6099 
6100 
6101 
6102 
6103 
6104 
6105 
6106 
6107 
6108 
6109 
6110 
6111 
6112 
6113 
6114 
6115 
6116 
6117 
6118 
6119 
6120 
6121 
6122 
6123 
6124 
6125 
6126 
6127 
6128 struct {
6129   struct spinlock lock;
6130   struct inode inode[NINODE];
6131 } icache;
6132 
6133 void
6134 iinit(int dev)
6135 {
6136   int i = 0;
6137 
6138   initlock(&icache.lock, "icache");
6139   for(i = 0; i < NINODE; i++) {
6140     initsleeplock(&icache.inode[i].lock, "inode");
6141   }
6142 
6143   readsb(dev, &sb);
6144   cprintf("sb: size %d nblocks %d ninodes %d nlog %d logstart %d\
6145  inodestart %d bmap start %d\n", sb.size, sb.nblocks,
6146           sb.ninodes, sb.nlog, sb.logstart, sb.inodestart,
6147           sb.bmapstart);
6148 }
6149 
6150 static struct inode* iget(uint dev, uint inum);
6151 
6152 
6153 
6154 
6155 
6156 
6157 
6158 
6159 
6160 
6161 
6162 
6163 
6164 
6165 
6166 
6167 
6168 
6169 
6170 
6171 
6172 
6173 
6174 
6175 
6176 
6177 
6178 
6179 
6180 
6181 
6182 
6183 
6184 
6185 
6186 
6187 
6188 
6189 
6190 
6191 
6192 
6193 
6194 
6195 
6196 
6197 
6198 
6199 
6200 
6201 
6202 struct inode*
6203 ialloc(uint dev, short type)
6204 {
6205   int inum;
6206   struct buf *bp;
6207   struct dinode *dip;
6208 
6209   for(inum = 1; inum < sb.ninodes; inum++){
6210     bp = bread(dev, IBLOCK(inum, sb));
6211     dip = (struct dinode*)bp->data + inum%IPB;
6212     if(dip->type == 0){  
6213       memset(dip, 0, sizeof(*dip));
6214       dip->type = type;
6215       log_write(bp);   
6216       brelse(bp);
6217       return iget(dev, inum);
6218     }
6219     brelse(bp);
6220   }
6221   panic("ialloc: no inodes");
6222 }
6223 
6224 
6225 void
6226 iupdate(struct inode *ip)
6227 {
6228   struct buf *bp;
6229   struct dinode *dip;
6230 
6231   bp = bread(ip->dev, IBLOCK(ip->inum, sb));
6232   dip = (struct dinode*)bp->data + ip->inum%IPB;
6233   dip->type = ip->type;
6234   dip->major = ip->major;
6235   dip->minor = ip->minor;
6236   dip->nlink = ip->nlink;
6237   dip->size = ip->size;
6238   memmove(dip->addrs, ip->addrs, sizeof(ip->addrs));
6239   log_write(bp);
6240   brelse(bp);
6241 }
6242 
6243 
6244 
6245 
6246 
6247 
6248 
6249 
6250 
6251 
6252 
6253 static struct inode*
6254 iget(uint dev, uint inum)
6255 {
6256   struct inode *ip, *empty;
6257 
6258   acquire(&icache.lock);
6259 
6260   
6261   empty = 0;
6262   for(ip = &icache.inode[0]; ip < &icache.inode[NINODE]; ip++){
6263     if(ip->ref > 0 && ip->dev == dev && ip->inum == inum){
6264       ip->ref++;
6265       release(&icache.lock);
6266       return ip;
6267     }
6268     if(empty == 0 && ip->ref == 0)    
6269       empty = ip;
6270   }
6271 
6272   
6273   if(empty == 0)
6274     panic("iget: no inodes");
6275 
6276   ip = empty;
6277   ip->dev = dev;
6278   ip->inum = inum;
6279   ip->ref = 1;
6280   ip->flags = 0;
6281   release(&icache.lock);
6282 
6283   return ip;
6284 }
6285 
6286 
6287 
6288 struct inode*
6289 idup(struct inode *ip)
6290 {
6291   acquire(&icache.lock);
6292   ip->ref++;
6293   release(&icache.lock);
6294   return ip;
6295 }
6296 
6297 
6298 
6299 
6300 
6301 
6302 void
6303 ilock(struct inode *ip)
6304 {
6305   struct buf *bp;
6306   struct dinode *dip;
6307 
6308   if(ip == 0 || ip->ref < 1)
6309     panic("ilock");
6310 
6311   acquiresleep(&ip->lock);
6312 
6313   if(!(ip->flags & I_VALID)){
6314     bp = bread(ip->dev, IBLOCK(ip->inum, sb));
6315     dip = (struct dinode*)bp->data + ip->inum%IPB;
6316     ip->type = dip->type;
6317     ip->major = dip->major;
6318     ip->minor = dip->minor;
6319     ip->nlink = dip->nlink;
6320     ip->size = dip->size;
6321     memmove(ip->addrs, dip->addrs, sizeof(ip->addrs));
6322     brelse(bp);
6323     ip->flags |= I_VALID;
6324     if(ip->type == 0)
6325       panic("ilock: no type");
6326   }
6327 }
6328 
6329 
6330 void
6331 iunlock(struct inode *ip)
6332 {
6333   if(ip == 0 || !holdingsleep(&ip->lock) || ip->ref < 1)
6334     panic("iunlock");
6335 
6336   releasesleep(&ip->lock);
6337 }
6338 
6339 
6340 
6341 
6342 
6343 
6344 
6345 
6346 
6347 
6348 
6349 
6350 
6351 
6352 
6353 
6354 
6355 
6356 
6357 void
6358 iput(struct inode *ip)
6359 {
6360   acquire(&icache.lock);
6361   if(ip->ref == 1 && (ip->flags & I_VALID) && ip->nlink == 0){
6362     
6363     release(&icache.lock);
6364     itrunc(ip);
6365     ip->type = 0;
6366     iupdate(ip);
6367     acquire(&icache.lock);
6368     ip->flags = 0;
6369   }
6370   ip->ref--;
6371   release(&icache.lock);
6372 }
6373 
6374 
6375 void
6376 iunlockput(struct inode *ip)
6377 {
6378   iunlock(ip);
6379   iput(ip);
6380 }
6381 
6382 
6383 
6384 
6385 
6386 
6387 
6388 
6389 
6390 
6391 
6392 
6393 
6394 
6395 
6396 
6397 
6398 
6399 
6400 
6401 
6402 
6403 
6404 
6405 
6406 
6407 
6408 
6409 static uint
6410 bmap(struct inode *ip, uint bn)
6411 {
6412   uint addr, *a;
6413   struct buf *bp;
6414 
6415   if(bn < NDIRECT){
6416     if((addr = ip->addrs[bn]) == 0)
6417       ip->addrs[bn] = addr = balloc(ip->dev);
6418     return addr;
6419   }
6420   bn -= NDIRECT;
6421 
6422   if(bn < NINDIRECT){
6423     
6424     if((addr = ip->addrs[NDIRECT]) == 0)
6425       ip->addrs[NDIRECT] = addr = balloc(ip->dev);
6426     bp = bread(ip->dev, addr);
6427     a = (uint*)bp->data;
6428     if((addr = a[bn]) == 0){
6429       a[bn] = addr = balloc(ip->dev);
6430       log_write(bp);
6431     }
6432     brelse(bp);
6433     return addr;
6434   }
6435 
6436   panic("bmap: out of range");
6437 }
6438 
6439 
6440 
6441 
6442 
6443 
6444 
6445 
6446 
6447 
6448 
6449 
6450 
6451 
6452 
6453 
6454 
6455 static void
6456 itrunc(struct inode *ip)
6457 {
6458   int i, j;
6459   struct buf *bp;
6460   uint *a;
6461 
6462   for(i = 0; i < NDIRECT; i++){
6463     if(ip->addrs[i]){
6464       bfree(ip->dev, ip->addrs[i]);
6465       ip->addrs[i] = 0;
6466     }
6467   }
6468 
6469   if(ip->addrs[NDIRECT]){
6470     bp = bread(ip->dev, ip->addrs[NDIRECT]);
6471     a = (uint*)bp->data;
6472     for(j = 0; j < NINDIRECT; j++){
6473       if(a[j])
6474         bfree(ip->dev, a[j]);
6475     }
6476     brelse(bp);
6477     bfree(ip->dev, ip->addrs[NDIRECT]);
6478     ip->addrs[NDIRECT] = 0;
6479   }
6480 
6481   ip->size = 0;
6482   iupdate(ip);
6483 }
6484 
6485 
6486 void
6487 stati(struct inode *ip, struct stat *st)
6488 {
6489   st->dev = ip->dev;
6490   st->ino = ip->inum;
6491   st->type = ip->type;
6492   st->nlink = ip->nlink;
6493   st->size = ip->size;
6494 }
6495 
6496 
6497 
6498 
6499 
6500 
6501 int
6502 readi(struct inode *ip, char *dst, uint off, uint n)
6503 {
6504   uint tot, m;
6505   struct buf *bp;
6506 
6507   if(ip->type == T_DEV){
6508     if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].read)
6509       return -1;
6510     return devsw[ip->major].read(ip, dst, n);
6511   }
6512 
6513   if(off > ip->size || off + n < off)
6514     return -1;
6515   if(off + n > ip->size)
6516     n = ip->size - off;
6517 
6518   for(tot=0; tot<n; tot+=m, off+=m, dst+=m){
6519     bp = bread(ip->dev, bmap(ip, off/BSIZE));
6520     m = min(n - tot, BSIZE - off%BSIZE);
6521     /*
6522     cprintf("data off %d:\n", off);
6523     for (int j = 0; j < min(m, 10); j++) {
6524       cprintf("%x ", bp->data[off%BSIZE+j]);
6525     }
6526     cprintf("\n");
6527     */
6528     memmove(dst, bp->data + off%BSIZE, m);
6529     brelse(bp);
6530   }
6531   return n;
6532 }
6533 
6534 
6535 
6536 
6537 
6538 
6539 
6540 
6541 
6542 
6543 
6544 
6545 
6546 
6547 
6548 
6549 
6550 
6551 int
6552 writei(struct inode *ip, char *src, uint off, uint n)
6553 {
6554   uint tot, m;
6555   struct buf *bp;
6556 
6557   if(ip->type == T_DEV){
6558     if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].write)
6559       return -1;
6560     return devsw[ip->major].write(ip, src, n);
6561   }
6562 
6563   if(off > ip->size || off + n < off)
6564     return -1;
6565   if(off + n > MAXFILE*BSIZE)
6566     return -1;
6567 
6568   for(tot=0; tot<n; tot+=m, off+=m, src+=m){
6569     bp = bread(ip->dev, bmap(ip, off/BSIZE));
6570     m = min(n - tot, BSIZE - off%BSIZE);
6571     memmove(bp->data + off%BSIZE, src, m);
6572     log_write(bp);
6573     brelse(bp);
6574   }
6575 
6576   if(n > 0 && off > ip->size){
6577     ip->size = off;
6578     iupdate(ip);
6579   }
6580   return n;
6581 }
6582 
6583 
6584 
6585 
6586 
6587 
6588 
6589 
6590 
6591 
6592 
6593 
6594 
6595 
6596 
6597 
6598 
6599 
6600 
6601 
6602 int
6603 namecmp(const char *s, const char *t)
6604 {
6605   return strncmp(s, t, DIRSIZ);
6606 }
6607 
6608 
6609 
6610 struct inode*
6611 dirlookup(struct inode *dp, char *name, uint *poff)
6612 {
6613   uint off, inum;
6614   struct dirent de;
6615 
6616   if(dp->type != T_DIR)
6617     panic("dirlookup not DIR");
6618 
6619   for(off = 0; off < dp->size; off += sizeof(de)){
6620     if(readi(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
6621       panic("dirlink read");
6622     if(de.inum == 0)
6623       continue;
6624     if(namecmp(name, de.name) == 0){
6625       
6626       if(poff)
6627         *poff = off;
6628       inum = de.inum;
6629       return iget(dp->dev, inum);
6630     }
6631   }
6632 
6633   return 0;
6634 }
6635 
6636 
6637 
6638 
6639 
6640 
6641 
6642 
6643 
6644 
6645 
6646 
6647 
6648 
6649 
6650 
6651 int
6652 dirlink(struct inode *dp, char *name, uint inum)
6653 {
6654   int off;
6655   struct dirent de;
6656   struct inode *ip;
6657 
6658   
6659   if((ip = dirlookup(dp, name, 0)) != 0){
6660     iput(ip);
6661     return -1;
6662   }
6663 
6664   
6665   for(off = 0; off < dp->size; off += sizeof(de)){
6666     if(readi(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
6667       panic("dirlink read");
6668     if(de.inum == 0)
6669       break;
6670   }
6671 
6672   strncpy(de.name, name, DIRSIZ);
6673   de.inum = inum;
6674   if(writei(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
6675     panic("dirlink");
6676 
6677   return 0;
6678 }
6679 
6680 
6681 
6682 
6683 
6684 
6685 
6686 
6687 
6688 
6689 
6690 
6691 
6692 
6693 
6694 
6695 
6696 
6697 
6698 
6699 
6700 
6701 
6702 
6703 
6704 
6705 
6706 
6707 
6708 
6709 
6710 
6711 
6712 
6713 
6714 static char*
6715 skipelem(char *path, char *name)
6716 {
6717   char *s;
6718   int len;
6719 
6720   while(*path == '/')
6721     path++;
6722   if(*path == 0)
6723     return 0;
6724   s = path;
6725   while(*path != '/' && *path != 0)
6726     path++;
6727   len = path - s;
6728   if(len >= DIRSIZ)
6729     memmove(name, s, DIRSIZ);
6730   else {
6731     memmove(name, s, len);
6732     name[len] = 0;
6733   }
6734   while(*path == '/')
6735     path++;
6736   return path;
6737 }
6738 
6739 
6740 
6741 
6742 
6743 
6744 
6745 
6746 
6747 
6748 
6749 
6750 
6751 
6752 
6753 
6754 static struct inode*
6755 namex(char *path, int nameiparent, char *name)
6756 {
6757   struct inode *ip, *next;
6758 
6759   if(*path == '/')
6760     ip = iget(ROOTDEV, ROOTINO);
6761   else
6762     ip = idup(proc->cwd);
6763 
6764   while((path = skipelem(path, name)) != 0){
6765     ilock(ip);
6766     if(ip->type != T_DIR){
6767       iunlockput(ip);
6768       return 0;
6769     }
6770     if(nameiparent && *path == '\0'){
6771       
6772       iunlock(ip);
6773       return ip;
6774     }
6775     if((next = dirlookup(ip, name, 0)) == 0){
6776       iunlockput(ip);
6777       return 0;
6778     }
6779     iunlockput(ip);
6780     ip = next;
6781   }
6782   if(nameiparent){
6783     iput(ip);
6784     return 0;
6785   }
6786   return ip;
6787 }
6788 
6789 struct inode*
6790 namei(char *path)
6791 {
6792   char name[DIRSIZ];
6793   return namex(path, 0, name);
6794 }
6795 
6796 
6797 
6798 
6799 
6800 struct inode*
6801 nameiparent(char *path, char *name)
6802 {
6803   return namex(path, 1, name);
6804 }
6805 
6806 
6807 
6808 
6809 
6810 
6811 
6812 
6813 
6814 
6815 
6816 
6817 
6818 
6819 
6820 
6821 
6822 
6823 
6824 
6825 
6826 
6827 
6828 
6829 
6830 
6831 
6832 
6833 
6834 
6835 
6836 
6837 
6838 
6839 
6840 
6841 
6842 
6843 
6844 
6845 
6846 
6847 
6848 
6849 
6850 
6851 
6852 
6853 
6854 #include "types.h"
6855 #include "defs.h"
6856 #include "param.h"
6857 #include "fs.h"
6858 #include "spinlock.h"
6859 #include "sleeplock.h"
6860 #include "file.h"
6861 
6862 struct devsw devsw[NDEV];
6863 struct {
6864   struct spinlock lock;
6865   struct file file[NFILE];
6866 } ftable;
6867 
6868 void
6869 fileinit(void)
6870 {
6871   initlock(&ftable.lock, "ftable");
6872 }
6873 
6874 
6875 struct file*
6876 filealloc(void)
6877 {
6878   struct file *f;
6879 
6880   acquire(&ftable.lock);
6881   for(f = ftable.file; f < ftable.file + NFILE; f++){
6882     if(f->ref == 0){
6883       f->ref = 1;
6884       release(&ftable.lock);
6885       return f;
6886     }
6887   }
6888   release(&ftable.lock);
6889   return 0;
6890 }
6891 
6892 
6893 
6894 
6895 
6896 
6897 
6898 
6899 
6900 
6901 struct file*
6902 filedup(struct file *f)
6903 {
6904   acquire(&ftable.lock);
6905   if(f->ref < 1)
6906     panic("filedup");
6907   f->ref++;
6908   release(&ftable.lock);
6909   return f;
6910 }
6911 
6912 
6913 void
6914 fileclose(struct file *f)
6915 {
6916   struct file ff;
6917 
6918   acquire(&ftable.lock);
6919   if(f->ref < 1)
6920     panic("fileclose");
6921   if(--f->ref > 0){
6922     release(&ftable.lock);
6923     return;
6924   }
6925   ff = *f;
6926   f->ref = 0;
6927   f->type = FD_NONE;
6928   release(&ftable.lock);
6929 
6930   if(ff.type == FD_PIPE)
6931     pipeclose(ff.pipe, ff.writable);
6932   else if(ff.type == FD_INODE){
6933     begin_op();
6934     iput(ff.ip);
6935     end_op();
6936   }
6937 }
6938 
6939 
6940 
6941 
6942 
6943 
6944 
6945 
6946 
6947 
6948 
6949 
6950 
6951 int
6952 filestat(struct file *f, struct stat *st)
6953 {
6954   if(f->type == FD_INODE){
6955     ilock(f->ip);
6956     stati(f->ip, st);
6957     iunlock(f->ip);
6958     return 0;
6959   }
6960   return -1;
6961 }
6962 
6963 
6964 int
6965 fileread(struct file *f, char *addr, int n)
6966 {
6967   int r;
6968 
6969   if(f->readable == 0)
6970     return -1;
6971   if(f->type == FD_PIPE)
6972     return piperead(f->pipe, addr, n);
6973   if(f->type == FD_INODE){
6974     ilock(f->ip);
6975     if((r = readi(f->ip, addr, f->off, n)) > 0)
6976       f->off += r;
6977     iunlock(f->ip);
6978     return r;
6979   }
6980   panic("fileread");
6981 }
6982 
6983 
6984 
6985 
6986 
6987 
6988 
6989 
6990 
6991 
6992 
6993 
6994 
6995 
6996 
6997 
6998 
6999 
7000 
7001 int
7002 filewrite(struct file *f, char *addr, int n)
7003 {
7004   int r;
7005 
7006   if(f->writable == 0)
7007     return -1;
7008   if(f->type == FD_PIPE)
7009     return pipewrite(f->pipe, addr, n);
7010   if(f->type == FD_INODE){
7011     
7012     
7013     
7014     
7015     
7016     
7017     int max = ((LOGSIZE-1-1-2) / 2) * 512;
7018     int i = 0;
7019     while(i < n){
7020       int n1 = n - i;
7021       if(n1 > max)
7022         n1 = max;
7023 
7024       begin_op();
7025       ilock(f->ip);
7026       if ((r = writei(f->ip, addr + i, f->off, n1)) > 0)
7027         f->off += r;
7028       iunlock(f->ip);
7029       end_op();
7030 
7031       if(r < 0)
7032         break;
7033       if(r != n1)
7034         panic("short filewrite");
7035       i += r;
7036     }
7037     return i == n ? n : -1;
7038   }
7039   panic("filewrite");
7040 }
7041 
7042 
7043 
7044 
7045 
7046 
7047 
7048 
7049 
7050 
7051 
7052 
7053 
7054 
7055 
7056 #include "types.h"
7057 #include "defs.h"
7058 #include "param.h"
7059 #include "stat.h"
7060 #include "mmu.h"
7061 #include "proc.h"
7062 #include "fs.h"
7063 #include "spinlock.h"
7064 #include "sleeplock.h"
7065 #include "file.h"
7066 #include "fcntl.h"
7067 
7068 
7069 
7070 static int
7071 argfd(int n, int *pfd, struct file **pf)
7072 {
7073   int fd;
7074   struct file *f;
7075 
7076   if(argint(n, &fd) < 0)
7077     return -1;
7078   if(fd < 0 || fd >= NOFILE || (f=proc->ofile[fd]) == 0)
7079     return -1;
7080   if(pfd)
7081     *pfd = fd;
7082   if(pf)
7083     *pf = f;
7084   return 0;
7085 }
7086 
7087 
7088 
7089 
7090 
7091 
7092 
7093 
7094 
7095 
7096 
7097 
7098 
7099 
7100 
7101 
7102 static int
7103 fdalloc(struct file *f)
7104 {
7105   int fd;
7106 
7107   for(fd = 0; fd < NOFILE; fd++){
7108     if(proc->ofile[fd] == 0){
7109       proc->ofile[fd] = f;
7110       return fd;
7111     }
7112   }
7113   return -1;
7114 }
7115 
7116 int
7117 sys_dup(void)
7118 {
7119   struct file *f;
7120   int fd;
7121 
7122   if(argfd(0, 0, &f) < 0)
7123     return -1;
7124   if((fd=fdalloc(f)) < 0)
7125     return -1;
7126   filedup(f);
7127   return fd;
7128 }
7129 
7130 int
7131 sys_read(void)
7132 {
7133   struct file *f;
7134   int n;
7135   char *p;
7136 
7137   if(argfd(0, 0, &f) < 0 || argint(2, &n) < 0 || argptr(1, &p, n) < 0)
7138     return -1;
7139   return fileread(f, p, n);
7140 }
7141 
7142 
7143 
7144 
7145 
7146 
7147 
7148 
7149 
7150 int
7151 sys_write(void)
7152 {
7153   struct file *f;
7154   int n;
7155   char *p;
7156 
7157   if(argfd(0, 0, &f) < 0 || argint(2, &n) < 0 || argptr(1, &p, n) < 0)
7158     return -1;
7159   return filewrite(f, p, n);
7160 }
7161 
7162 int
7163 sys_close(void)
7164 {
7165   int fd;
7166   struct file *f;
7167 
7168   if(argfd(0, &fd, &f) < 0)
7169     return -1;
7170   proc->ofile[fd] = 0;
7171   fileclose(f);
7172   return 0;
7173 }
7174 
7175 int
7176 sys_fstat(void)
7177 {
7178   struct file *f;
7179   struct stat *st;
7180 
7181   if(argfd(0, 0, &f) < 0 || argptr(1, (void*)&st, sizeof(*st)) < 0)
7182     return -1;
7183   return filestat(f, st);
7184 }
7185 
7186 
7187 
7188 
7189 
7190 
7191 
7192 
7193 
7194 
7195 
7196 
7197 
7198 
7199 
7200 
7201 int
7202 sys_link(void)
7203 {
7204   char name[DIRSIZ], *new, *old;
7205   struct inode *dp, *ip;
7206 
7207   if(argstr(0, &old) < 0 || argstr(1, &new) < 0)
7208     return -1;
7209 
7210   begin_op();
7211   if((ip = namei(old)) == 0){
7212     end_op();
7213     return -1;
7214   }
7215 
7216   ilock(ip);
7217   if(ip->type == T_DIR){
7218     iunlockput(ip);
7219     end_op();
7220     return -1;
7221   }
7222 
7223   ip->nlink++;
7224   iupdate(ip);
7225   iunlock(ip);
7226 
7227   if((dp = nameiparent(new, name)) == 0)
7228     goto bad;
7229   ilock(dp);
7230   if(dp->dev != ip->dev || dirlink(dp, name, ip->inum) < 0){
7231     iunlockput(dp);
7232     goto bad;
7233   }
7234   iunlockput(dp);
7235   iput(ip);
7236 
7237   end_op();
7238 
7239   return 0;
7240 
7241 bad:
7242   ilock(ip);
7243   ip->nlink--;
7244   iupdate(ip);
7245   iunlockput(ip);
7246   end_op();
7247   return -1;
7248 }
7249 
7250 
7251 static int
7252 isdirempty(struct inode *dp)
7253 {
7254   int off;
7255   struct dirent de;
7256 
7257   for(off=2*sizeof(de); off<dp->size; off+=sizeof(de)){
7258     if(readi(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
7259       panic("isdirempty: readi");
7260     if(de.inum != 0)
7261       return 0;
7262   }
7263   return 1;
7264 }
7265 
7266 
7267 
7268 
7269 
7270 
7271 
7272 
7273 
7274 
7275 
7276 
7277 
7278 
7279 
7280 
7281 
7282 
7283 
7284 
7285 
7286 
7287 
7288 
7289 
7290 
7291 
7292 
7293 
7294 
7295 
7296 
7297 
7298 
7299 
7300 int
7301 sys_unlink(void)
7302 {
7303   struct inode *ip, *dp;
7304   struct dirent de;
7305   char name[DIRSIZ], *path;
7306   uint off;
7307 
7308   if(argstr(0, &path) < 0)
7309     return -1;
7310 
7311   begin_op();
7312   if((dp = nameiparent(path, name)) == 0){
7313     end_op();
7314     return -1;
7315   }
7316 
7317   ilock(dp);
7318 
7319   
7320   if(namecmp(name, ".") == 0 || namecmp(name, "..") == 0)
7321     goto bad;
7322 
7323   if((ip = dirlookup(dp, name, &off)) == 0)
7324     goto bad;
7325   ilock(ip);
7326 
7327   if(ip->nlink < 1)
7328     panic("unlink: nlink < 1");
7329   if(ip->type == T_DIR && !isdirempty(ip)){
7330     iunlockput(ip);
7331     goto bad;
7332   }
7333 
7334   memset(&de, 0, sizeof(de));
7335   if(writei(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
7336     panic("unlink: writei");
7337   if(ip->type == T_DIR){
7338     dp->nlink--;
7339     iupdate(dp);
7340   }
7341   iunlockput(dp);
7342 
7343   ip->nlink--;
7344   iupdate(ip);
7345   iunlockput(ip);
7346 
7347   end_op();
7348 
7349   return 0;
7350 bad:
7351   iunlockput(dp);
7352   end_op();
7353   return -1;
7354 }
7355 
7356 static struct inode*
7357 create(char *path, short type, short major, short minor)
7358 {
7359   uint off;
7360   struct inode *ip, *dp;
7361   char name[DIRSIZ];
7362 
7363   if((dp = nameiparent(path, name)) == 0)
7364     return 0;
7365   ilock(dp);
7366 
7367   if((ip = dirlookup(dp, name, &off)) != 0){
7368     iunlockput(dp);
7369     ilock(ip);
7370     if(type == T_FILE && ip->type == T_FILE)
7371       return ip;
7372     iunlockput(ip);
7373     return 0;
7374   }
7375 
7376   if((ip = ialloc(dp->dev, type)) == 0)
7377     panic("create: ialloc");
7378 
7379   ilock(ip);
7380   ip->major = major;
7381   ip->minor = minor;
7382   ip->nlink = 1;
7383   iupdate(ip);
7384 
7385   if(type == T_DIR){  
7386     dp->nlink++;  
7387     iupdate(dp);
7388     
7389     if(dirlink(ip, ".", ip->inum) < 0 || dirlink(ip, "..", dp->inum) < 0)
7390       panic("create dots");
7391   }
7392 
7393   if(dirlink(dp, name, ip->inum) < 0)
7394     panic("create: dirlink");
7395 
7396   iunlockput(dp);
7397 
7398   return ip;
7399 }
7400 int
7401 sys_open(void)
7402 {
7403   char *path;
7404   int fd, omode;
7405   struct file *f;
7406   struct inode *ip;
7407 
7408   if(argstr(0, &path) < 0 || argint(1, &omode) < 0)
7409     return -1;
7410 
7411   begin_op();
7412 
7413   if(omode & O_CREATE){
7414     ip = create(path, T_FILE, 0, 0);
7415     if(ip == 0){
7416       end_op();
7417       return -1;
7418     }
7419   } else {
7420     if((ip = namei(path)) == 0){
7421       end_op();
7422       return -1;
7423     }
7424     ilock(ip);
7425     if(ip->type == T_DIR && omode != O_RDONLY){
7426       iunlockput(ip);
7427       end_op();
7428       return -1;
7429     }
7430   }
7431 
7432   if((f = filealloc()) == 0 || (fd = fdalloc(f)) < 0){
7433     if(f)
7434       fileclose(f);
7435     iunlockput(ip);
7436     end_op();
7437     return -1;
7438   }
7439   iunlock(ip);
7440   end_op();
7441 
7442   f->type = FD_INODE;
7443   f->ip = ip;
7444   f->off = 0;
7445   f->readable = !(omode & O_WRONLY);
7446   f->writable = (omode & O_WRONLY) || (omode & O_RDWR);
7447   return fd;
7448 }
7449 
7450 int
7451 sys_mkdir(void)
7452 {
7453   char *path;
7454   struct inode *ip;
7455 
7456   begin_op();
7457   if(argstr(0, &path) < 0 || (ip = create(path, T_DIR, 0, 0)) == 0){
7458     end_op();
7459     return -1;
7460   }
7461   iunlockput(ip);
7462   end_op();
7463   return 0;
7464 }
7465 
7466 int
7467 sys_mknod(void)
7468 {
7469   struct inode *ip;
7470   char *path;
7471   int major, minor;
7472 
7473   begin_op();
7474   if((argstr(0, &path)) < 0 ||
7475      argint(1, &major) < 0 ||
7476      argint(2, &minor) < 0 ||
7477      (ip = create(path, T_DEV, major, minor)) == 0){
7478     end_op();
7479     return -1;
7480   }
7481   iunlockput(ip);
7482   end_op();
7483   return 0;
7484 }
7485 
7486 
7487 
7488 
7489 
7490 
7491 
7492 
7493 
7494 
7495 
7496 
7497 
7498 
7499 
7500 int
7501 sys_chdir(void)
7502 {
7503   char *path;
7504   struct inode *ip;
7505 
7506   begin_op();
7507   if(argstr(0, &path) < 0 || (ip = namei(path)) == 0){
7508     end_op();
7509     return -1;
7510   }
7511   ilock(ip);
7512   if(ip->type != T_DIR){
7513     iunlockput(ip);
7514     end_op();
7515     return -1;
7516   }
7517   iunlock(ip);
7518   iput(proc->cwd);
7519   end_op();
7520   proc->cwd = ip;
7521   return 0;
7522 }
7523 
7524 int
7525 sys_exec(void)
7526 {
7527   char *path, *argv[MAXARG];
7528   int i;
7529   uint uargv, uarg;
7530 
7531   if(argstr(0, &path) < 0 || argint(1, (int*)&uargv) < 0){
7532     return -1;
7533   }
7534   memset(argv, 0, sizeof(argv));
7535   for(i=0;; i++){
7536     if(i >= NELEM(argv))
7537       return -1;
7538     if(fetchint(uargv+4*i, (int*)&uarg) < 0)
7539       return -1;
7540     if(uarg == 0){
7541       argv[i] = 0;
7542       break;
7543     }
7544     if(fetchstr(uarg, &argv[i]) < 0)
7545       return -1;
7546   }
7547   return exec(path, argv);
7548 }
7549 
7550 int
7551 sys_pipe(void)
7552 {
7553   int *fd;
7554   struct file *rf, *wf;
7555   int fd0, fd1;
7556 
7557   if(argptr(0, (void*)&fd, 2*sizeof(fd[0])) < 0)
7558     return -1;
7559   if(pipealloc(&rf, &wf) < 0)
7560     return -1;
7561   fd0 = -1;
7562   
7563   if((fd0 = fdalloc(rf)) < 0 || (fd1 = fdalloc(wf)) < 0){
7564     if(fd0 >= 0)
7565       proc->ofile[fd0] = 0;
7566     fileclose(rf);
7567     fileclose(wf);
7568     return -1;
7569   }
7570   fd[0] = fd0;
7571   fd[1] = fd1;
7572   return 0;
7573 }
7574 
7575 
7576 
7577 
7578 
7579 
7580 
7581 
7582 
7583 
7584 
7585 
7586 
7587 
7588 
7589 
7590 
7591 
7592 
7593 
7594 
7595 
7596 
7597 
7598 
7599 
7600 #include "types.h"
7601 #include "param.h"
7602 #include "memlayout.h"
7603 #include "mmu.h"
7604 #include "proc.h"
7605 #include "defs.h"
7606 #include "x86.h"
7607 #include "elf.h"
7608 #include "mlfq.h"
7609 
7610     int
7611 exec(char *path, char **argv)
7612 {
7613     char *s, *last;
7614     int i, off;
7615     uint argc, sz, sp, ustack[3+MAXARG+1];
7616     struct elfhdr elf;
7617     struct inode *ip;
7618     struct proghdr ph;
7619     pde_t *pgdir, *oldpgdir;
7620 
7621     begin_op();
7622 
7623     if((ip = namei(path)) == 0){
7624         end_op();
7625         return -1;
7626     }
7627     ilock(ip);
7628     pgdir = 0;
7629 
7630     
7631     if(readi(ip, (char*)&elf, 0, sizeof(elf)) != sizeof(elf))
7632         goto bad;
7633     if(elf.magic != ELF_MAGIC)
7634         goto bad;
7635 
7636     if((pgdir = setupkvm()) == 0)
7637         goto bad;
7638 
7639     
7640     sz = 0;
7641     for(i=0, off=elf.phoff; i<elf.phnum; i++, off+=sizeof(ph)){
7642         if(readi(ip, (char*)&ph, off, sizeof(ph)) != sizeof(ph))
7643             goto bad;
7644         if(ph.type != ELF_PROG_LOAD)
7645             continue;
7646         if(ph.memsz < ph.filesz)
7647             goto bad;
7648         if(ph.vaddr + ph.memsz < ph.vaddr)
7649             goto bad;
7650         if((sz = allocuvm(pgdir, sz, ph.vaddr + ph.memsz)) == 0)
7651             goto bad;
7652         if(ph.vaddr % PGSIZE != 0)
7653             goto bad;
7654         if(loaduvm(pgdir, (char*)ph.vaddr, ip, ph.off, ph.filesz) < 0)
7655             goto bad;
7656     }
7657     iunlockput(ip);
7658     end_op();
7659     ip = 0;
7660 
7661     
7662     
7663     sz = PGROUNDUP(sz);
7664     if((sz = allocuvm(pgdir, sz, sz + 2*PGSIZE)) == 0)
7665         goto bad;
7666     clearpteu(pgdir, (char*)(sz - 2*PGSIZE));
7667     sp = sz;
7668 
7669     
7670     for(argc = 0; argv[argc]; argc++) {
7671         if(argc >= MAXARG)
7672             goto bad;
7673         sp = (sp - (strlen(argv[argc]) + 1)) & ~3;
7674         if(copyout(pgdir, sp, argv[argc], strlen(argv[argc]) + 1) < 0)
7675             goto bad;
7676         ustack[3+argc] = sp;
7677     }
7678     ustack[3+argc] = 0;
7679 
7680     ustack[0] = 0xffffffff;  
7681     ustack[1] = argc;
7682     ustack[2] = sp - (argc+1)*4;  
7683 
7684     sp -= (3+argc+1) * 4;
7685     if(copyout(pgdir, sp, ustack, (3+argc+1)*4) < 0)
7686         goto bad;
7687 
7688     
7689     for(last=s=path; *s; s++)
7690         if(*s == '/')
7691             last = s+1;
7692     safestrcpy(proc->name, last, sizeof(proc->name));
7693 
7694     
7695     oldpgdir = proc->pgdir;
7696     proc->pgdir = pgdir;
7697     proc->sz = sz;
7698     proc->tf->eip = elf.entry;  
7699     proc->tf->esp = sp;
7700     switchuvm(proc);
7701     if(proc->isthread ==0)
7702         freevm(oldpgdir);
7703 
7704     return 0;
7705 
7706 bad:
7707     if(pgdir)
7708         freevm(pgdir);
7709     if(ip){
7710         iunlockput(ip);
7711         end_op();
7712     }
7713     return -1;
7714 }
7715 
7716 
7717 
7718 
7719 
7720 
7721 
7722 
7723 
7724 
7725 
7726 
7727 
7728 
7729 
7730 
7731 
7732 
7733 
7734 
7735 
7736 
7737 
7738 
7739 
7740 
7741 
7742 
7743 
7744 
7745 
7746 
7747 
7748 
7749 
7750 #include "types.h"
7751 #include "defs.h"
7752 #include "param.h"
7753 #include "mmu.h"
7754 #include "proc.h"
7755 #include "fs.h"
7756 #include "spinlock.h"
7757 #include "sleeplock.h"
7758 #include "file.h"
7759 
7760 #define PIPESIZE 512
7761 
7762 struct pipe {
7763   struct spinlock lock;
7764   char data[PIPESIZE];
7765   uint nread;     
7766   uint nwrite;    
7767   int readopen;   
7768   int writeopen;  
7769 };
7770 
7771 int
7772 pipealloc(struct file **f0, struct file **f1)
7773 {
7774   struct pipe *p;
7775 
7776   p = 0;
7777   *f0 = *f1 = 0;
7778   if((*f0 = filealloc()) == 0 || (*f1 = filealloc()) == 0)
7779     goto bad;
7780   if((p = (struct pipe*)kalloc()) == 0)
7781     goto bad;
7782   p->readopen = 1;
7783   p->writeopen = 1;
7784   p->nwrite = 0;
7785   p->nread = 0;
7786   initlock(&p->lock, "pipe");
7787   (*f0)->type = FD_PIPE;
7788   (*f0)->readable = 1;
7789   (*f0)->writable = 0;
7790   (*f0)->pipe = p;
7791   (*f1)->type = FD_PIPE;
7792   (*f1)->readable = 0;
7793   (*f1)->writable = 1;
7794   (*f1)->pipe = p;
7795   return 0;
7796 
7797 
7798 
7799 
7800  bad:
7801   if(p)
7802     kfree((char*)p);
7803   if(*f0)
7804     fileclose(*f0);
7805   if(*f1)
7806     fileclose(*f1);
7807   return -1;
7808 }
7809 
7810 void
7811 pipeclose(struct pipe *p, int writable)
7812 {
7813   acquire(&p->lock);
7814   if(writable){
7815     p->writeopen = 0;
7816     wakeup(&p->nread);
7817   } else {
7818     p->readopen = 0;
7819     wakeup(&p->nwrite);
7820   }
7821   if(p->readopen == 0 && p->writeopen == 0){
7822     release(&p->lock);
7823     kfree((char*)p);
7824   } else
7825     release(&p->lock);
7826 }
7827 
7828 
7829 int
7830 pipewrite(struct pipe *p, char *addr, int n)
7831 {
7832   int i;
7833 
7834   acquire(&p->lock);
7835   for(i = 0; i < n; i++){
7836     while(p->nwrite == p->nread + PIPESIZE){  
7837       if(p->readopen == 0 || proc->killed){
7838         release(&p->lock);
7839         return -1;
7840       }
7841       wakeup(&p->nread);
7842       sleep(&p->nwrite, &p->lock);  
7843     }
7844     p->data[p->nwrite++ % PIPESIZE] = addr[i];
7845   }
7846   wakeup(&p->nread);  
7847   release(&p->lock);
7848   return n;
7849 }
7850 int
7851 piperead(struct pipe *p, char *addr, int n)
7852 {
7853   int i;
7854 
7855   acquire(&p->lock);
7856   while(p->nread == p->nwrite && p->writeopen){  
7857     if(proc->killed){
7858       release(&p->lock);
7859       return -1;
7860     }
7861     sleep(&p->nread, &p->lock); 
7862   }
7863   for(i = 0; i < n; i++){  
7864     if(p->nread == p->nwrite)
7865       break;
7866     addr[i] = p->data[p->nread++ % PIPESIZE];
7867   }
7868   wakeup(&p->nwrite);  
7869   release(&p->lock);
7870   return i;
7871 }
7872 
7873 
7874 
7875 
7876 
7877 
7878 
7879 
7880 
7881 
7882 
7883 
7884 
7885 
7886 
7887 
7888 
7889 
7890 
7891 
7892 
7893 
7894 
7895 
7896 
7897 
7898 
7899 
7900 #include "types.h"
7901 #include "x86.h"
7902 
7903 void*
7904 memset(void *dst, int c, uint n)
7905 {
7906   if ((int)dst%4 == 0 && n%4 == 0){
7907     c &= 0xFF;
7908     stosl(dst, (c<<24)|(c<<16)|(c<<8)|c, n/4);
7909   } else
7910     stosb(dst, c, n);
7911   return dst;
7912 }
7913 
7914 int
7915 memcmp(const void *v1, const void *v2, uint n)
7916 {
7917   const uchar *s1, *s2;
7918 
7919   s1 = v1;
7920   s2 = v2;
7921   while(n-- > 0){
7922     if(*s1 != *s2)
7923       return *s1 - *s2;
7924     s1++, s2++;
7925   }
7926 
7927   return 0;
7928 }
7929 
7930 void*
7931 memmove(void *dst, const void *src, uint n)
7932 {
7933   const char *s;
7934   char *d;
7935 
7936   s = src;
7937   d = dst;
7938   if(s < d && s + n > d){
7939     s += n;
7940     d += n;
7941     while(n-- > 0)
7942       *--d = *--s;
7943   } else
7944     while(n-- > 0)
7945       *d++ = *s++;
7946 
7947   return dst;
7948 }
7949 
7950 
7951 void*
7952 memcpy(void *dst, const void *src, uint n)
7953 {
7954   return memmove(dst, src, n);
7955 }
7956 
7957 int
7958 strncmp(const char *p, const char *q, uint n)
7959 {
7960   while(n > 0 && *p && *p == *q)
7961     n--, p++, q++;
7962   if(n == 0)
7963     return 0;
7964   return (uchar)*p - (uchar)*q;
7965 }
7966 
7967 char*
7968 strncpy(char *s, const char *t, int n)
7969 {
7970   char *os;
7971 
7972   os = s;
7973   while(n-- > 0 && (*s++ = *t++) != 0)
7974     ;
7975   while(n-- > 0)
7976     *s++ = 0;
7977   return os;
7978 }
7979 
7980 
7981 char*
7982 safestrcpy(char *s, const char *t, int n)
7983 {
7984   char *os;
7985 
7986   os = s;
7987   if(n <= 0)
7988     return os;
7989   while(--n > 0 && (*s++ = *t++) != 0)
7990     ;
7991   *s = 0;
7992   return os;
7993 }
7994 
7995 
7996 
7997 
7998 
7999 
8000 int
8001 strlen(const char *s)
8002 {
8003   int n;
8004 
8005   for(n = 0; s[n]; n++)
8006     ;
8007   return n;
8008 }
8009 
8010 
8011 
8012 
8013 
8014 
8015 
8016 
8017 
8018 
8019 
8020 
8021 
8022 
8023 
8024 
8025 
8026 
8027 
8028 
8029 
8030 
8031 
8032 
8033 
8034 
8035 
8036 
8037 
8038 
8039 
8040 
8041 
8042 
8043 
8044 
8045 
8046 
8047 
8048 
8049 
8050 
8051 
8052 struct mp {             
8053   uchar signature[4];           
8054   void *physaddr;               
8055   uchar length;                 
8056   uchar specrev;                
8057   uchar checksum;               
8058   uchar type;                   
8059   uchar imcrp;
8060   uchar reserved[3];
8061 };
8062 
8063 struct mpconf {         
8064   uchar signature[4];           
8065   ushort length;                
8066   uchar version;                
8067   uchar checksum;               
8068   uchar product[20];            
8069   uint *oemtable;               
8070   ushort oemlength;             
8071   ushort entry;                 
8072   uint *lapicaddr;              
8073   ushort xlength;               
8074   uchar xchecksum;              
8075   uchar reserved;
8076 };
8077 
8078 struct mpproc {         
8079   uchar type;                   
8080   uchar apicid;                 
8081   uchar version;                
8082   uchar flags;                  
8083     #define MPBOOT 0x02           
8084   uchar signature[4];           
8085   uint feature;                 
8086   uchar reserved[8];
8087 };
8088 
8089 struct mpioapic {       
8090   uchar type;                   
8091   uchar apicno;                 
8092   uchar version;                
8093   uchar flags;                  
8094   uint *addr;                  
8095 };
8096 
8097 
8098 
8099 
8100 
8101 #define MPPROC    0x00  
8102 #define MPBUS     0x01  
8103 #define MPIOAPIC  0x02  
8104 #define MPIOINTR  0x03  
8105 #define MPLINTR   0x04  
8106 
8107 
8108 
8109 
8110 
8111 
8112 
8113 
8114 
8115 
8116 
8117 
8118 
8119 
8120 
8121 
8122 
8123 
8124 
8125 
8126 
8127 
8128 
8129 
8130 
8131 
8132 
8133 
8134 
8135 
8136 
8137 
8138 
8139 
8140 
8141 
8142 
8143 
8144 
8145 
8146 
8147 
8148 
8149 
8150 
8151 
8152 
8153 
8154 
8155 
8156 
8157 
8158 
8159 
8160 
8161 
8162 
8163 
8164 
8165 
8166 
8167 
8168 
8169 
8170 
8171 
8172 
8173 
8174 
8175 
8176 
8177 
8178 
8179 
8180 
8181 
8182 
8183 
8184 
8185 
8186 
8187 
8188 
8189 
8190 
8191 
8192 
8193 
8194 
8195 
8196 
8197 
8198 
8199 
8200 
8201 
8202 
8203 
8204 #include "types.h"
8205 #include "defs.h"
8206 #include "param.h"
8207 #include "memlayout.h"
8208 #include "mp.h"
8209 #include "x86.h"
8210 #include "mmu.h"
8211 #include "proc.h"
8212 
8213 struct cpu cpus[NCPU];
8214 int ismp;
8215 int ncpu;
8216 uchar ioapicid;
8217 
8218 static uchar
8219 sum(uchar *addr, int len)
8220 {
8221   int i, sum;
8222 
8223   sum = 0;
8224   for(i=0; i<len; i++)
8225     sum += addr[i];
8226   return sum;
8227 }
8228 
8229 
8230 static struct mp*
8231 mpsearch1(uint a, int len)
8232 {
8233   uchar *e, *p, *addr;
8234 
8235   addr = P2V(a);
8236   e = addr+len;
8237   for(p = addr; p < e; p += sizeof(struct mp))
8238     if(memcmp(p, "_MP_", 4) == 0 && sum(p, sizeof(struct mp)) == 0)
8239       return (struct mp*)p;
8240   return 0;
8241 }
8242 
8243 
8244 
8245 
8246 
8247 
8248 
8249 
8250 
8251 
8252 
8253 
8254 
8255 static struct mp*
8256 mpsearch(void)
8257 {
8258   uchar *bda;
8259   uint p;
8260   struct mp *mp;
8261 
8262   bda = (uchar *) P2V(0x400);
8263   if((p = ((bda[0x0F]<<8)| bda[0x0E]) << 4)){
8264     if((mp = mpsearch1(p, 1024)))
8265       return mp;
8266   } else {
8267     p = ((bda[0x14]<<8)|bda[0x13])*1024;
8268     if((mp = mpsearch1(p-1024, 1024)))
8269       return mp;
8270   }
8271   return mpsearch1(0xF0000, 0x10000);
8272 }
8273 
8274 
8275 
8276 
8277 
8278 
8279 static struct mpconf*
8280 mpconfig(struct mp **pmp)
8281 {
8282   struct mpconf *conf;
8283   struct mp *mp;
8284 
8285   if((mp = mpsearch()) == 0 || mp->physaddr == 0)
8286     return 0;
8287   conf = (struct mpconf*) P2V((uint) mp->physaddr);
8288   if(memcmp(conf, "PCMP", 4) != 0)
8289     return 0;
8290   if(conf->version != 1 && conf->version != 4)
8291     return 0;
8292   if(sum((uchar*)conf, conf->length) != 0)
8293     return 0;
8294   *pmp = mp;
8295   return conf;
8296 }
8297 
8298 
8299 
8300 void
8301 mpinit(void)
8302 {
8303   uchar *p, *e;
8304   struct mp *mp;
8305   struct mpconf *conf;
8306   struct mpproc *proc;
8307   struct mpioapic *ioapic;
8308 
8309   if((conf = mpconfig(&mp)) == 0)
8310     return;
8311   ismp = 1;
8312   lapic = (uint*)conf->lapicaddr;
8313   for(p=(uchar*)(conf+1), e=(uchar*)conf+conf->length; p<e; ){
8314     switch(*p){
8315     case MPPROC:
8316       proc = (struct mpproc*)p;
8317       if(ncpu < NCPU) {
8318         cpus[ncpu].apicid = proc->apicid;  
8319         ncpu++;
8320       }
8321       p += sizeof(struct mpproc);
8322       continue;
8323     case MPIOAPIC:
8324       ioapic = (struct mpioapic*)p;
8325       ioapicid = ioapic->apicno;
8326       p += sizeof(struct mpioapic);
8327       continue;
8328     case MPBUS:
8329     case MPIOINTR:
8330     case MPLINTR:
8331       p += 8;
8332       continue;
8333     default:
8334       ismp = 0;
8335       break;
8336     }
8337   }
8338   if(!ismp){
8339     
8340     ncpu = 1;
8341     lapic = 0;
8342     ioapicid = 0;
8343     return;
8344   }
8345 
8346 
8347 
8348 
8349 
8350   if(mp->imcrp){
8351     
8352     
8353     outb(0x22, 0x70);   
8354     outb(0x23, inb(0x23) | 1);  
8355   }
8356 }
8357 
8358 
8359 
8360 
8361 
8362 
8363 
8364 
8365 
8366 
8367 
8368 
8369 
8370 
8371 
8372 
8373 
8374 
8375 
8376 
8377 
8378 
8379 
8380 
8381 
8382 
8383 
8384 
8385 
8386 
8387 
8388 
8389 
8390 
8391 
8392 
8393 
8394 
8395 
8396 
8397 
8398 
8399 
8400 
8401 
8402 
8403 #include "param.h"
8404 #include "types.h"
8405 #include "defs.h"
8406 #include "date.h"
8407 #include "memlayout.h"
8408 #include "traps.h"
8409 #include "mmu.h"
8410 #include "x86.h"
8411 #include "proc.h"  
8412 
8413 
8414 #define ID      (0x0020/4)   
8415 #define VER     (0x0030/4)   
8416 #define TPR     (0x0080/4)   
8417 #define EOI     (0x00B0/4)   
8418 #define SVR     (0x00F0/4)   
8419   #define ENABLE     0x00000100   
8420 #define ESR     (0x0280/4)   
8421 #define ICRLO   (0x0300/4)   
8422   #define INIT       0x00000500   
8423   #define STARTUP    0x00000600   
8424   #define DELIVS     0x00001000   
8425   #define ASSERT     0x00004000   
8426   #define DEASSERT   0x00000000
8427   #define LEVEL      0x00008000   
8428   #define BCAST      0x00080000   
8429   #define BUSY       0x00001000
8430   #define FIXED      0x00000000
8431 #define ICRHI   (0x0310/4)   
8432 #define TIMER   (0x0320/4)   
8433   #define X1         0x0000000B   
8434   #define PERIODIC   0x00020000   
8435 #define PCINT   (0x0340/4)   
8436 #define LINT0   (0x0350/4)   
8437 #define LINT1   (0x0360/4)   
8438 #define ERROR   (0x0370/4)   
8439   #define MASKED     0x00010000   
8440 #define TICR    (0x0380/4)   
8441 #define TCCR    (0x0390/4)   
8442 #define TDCR    (0x03E0/4)   
8443 
8444 volatile uint *lapic;  
8445 
8446 
8447 
8448 
8449 
8450 static void
8451 lapicw(int index, int value)
8452 {
8453   lapic[index] = value;
8454   lapic[ID];  
8455 }
8456 
8457 
8458 
8459 
8460 
8461 
8462 
8463 
8464 
8465 
8466 
8467 
8468 
8469 
8470 
8471 
8472 
8473 
8474 
8475 
8476 
8477 
8478 
8479 
8480 
8481 
8482 
8483 
8484 
8485 
8486 
8487 
8488 
8489 
8490 
8491 
8492 
8493 
8494 
8495 
8496 
8497 
8498 
8499 
8500 void
8501 lapicinit(void)
8502 {
8503   if(!lapic)
8504     return;
8505 
8506   
8507   lapicw(SVR, ENABLE | (T_IRQ0 + IRQ_SPURIOUS));
8508 
8509   
8510   
8511   
8512   
8513   lapicw(TDCR, X1);
8514   lapicw(TIMER, PERIODIC | (T_IRQ0 + IRQ_TIMER));
8515   lapicw(TICR, 10000000);
8516 
8517   
8518   lapicw(LINT0, MASKED);
8519   lapicw(LINT1, MASKED);
8520 
8521   
8522   
8523   if(((lapic[VER]>>16) & 0xFF) >= 4)
8524     lapicw(PCINT, MASKED);
8525 
8526   
8527   lapicw(ERROR, T_IRQ0 + IRQ_ERROR);
8528 
8529   
8530   lapicw(ESR, 0);
8531   lapicw(ESR, 0);
8532 
8533   
8534   lapicw(EOI, 0);
8535 
8536   
8537   lapicw(ICRHI, 0);
8538   lapicw(ICRLO, BCAST | INIT | LEVEL);
8539   while(lapic[ICRLO] & DELIVS)
8540     ;
8541 
8542   
8543   lapicw(TPR, 0);
8544 }
8545 
8546 
8547 
8548 
8549 
8550 int
8551 cpunum(void)
8552 {
8553   int apicid, i;
8554 
8555   
8556   
8557   
8558   
8559   
8560   if(readeflags()&FL_IF){
8561     static int n;
8562     if(n++ == 0)
8563       cprintf("cpu called from %x with interrupts enabled\n",
8564         __builtin_return_address(0));
8565   }
8566 
8567   if (!lapic)
8568     return 0;
8569 
8570   apicid = lapic[ID] >> 24;
8571   for (i = 0; i < ncpu; ++i) {
8572     if (cpus[i].apicid == apicid)
8573       return i;
8574   }
8575   panic("unknown apicid\n");
8576 }
8577 
8578 
8579 void
8580 lapiceoi(void)
8581 {
8582   if(lapic)
8583     lapicw(EOI, 0);
8584 }
8585 
8586 
8587 
8588 void
8589 microdelay(int us)
8590 {
8591 }
8592 
8593 
8594 
8595 
8596 
8597 
8598 
8599 
8600 #define CMOS_PORT    0x70
8601 #define CMOS_RETURN  0x71
8602 
8603 
8604 
8605 void
8606 lapicstartap(uchar apicid, uint addr)
8607 {
8608   int i;
8609   ushort *wrv;
8610 
8611   
8612   
8613   
8614   outb(CMOS_PORT, 0xF);  
8615   outb(CMOS_PORT+1, 0x0A);
8616   wrv = (ushort*)P2V((0x40<<4 | 0x67));  
8617   wrv[0] = 0;
8618   wrv[1] = addr >> 4;
8619 
8620   
8621   
8622   lapicw(ICRHI, apicid<<24);
8623   lapicw(ICRLO, INIT | LEVEL | ASSERT);
8624   microdelay(200);
8625   lapicw(ICRLO, INIT | LEVEL);
8626   microdelay(100);    
8627 
8628   
8629   
8630   
8631   
8632   
8633   for(i = 0; i < 2; i++){
8634     lapicw(ICRHI, apicid<<24);
8635     lapicw(ICRLO, STARTUP | (addr>>12));
8636     microdelay(200);
8637   }
8638 }
8639 
8640 
8641 
8642 
8643 
8644 
8645 
8646 
8647 
8648 
8649 
8650 #define CMOS_STATA   0x0a
8651 #define CMOS_STATB   0x0b
8652 #define CMOS_UIP    (1 << 7)        
8653 
8654 #define SECS    0x00
8655 #define MINS    0x02
8656 #define HOURS   0x04
8657 #define DAY     0x07
8658 #define MONTH   0x08
8659 #define YEAR    0x09
8660 
8661 static uint cmos_read(uint reg)
8662 {
8663   outb(CMOS_PORT,  reg);
8664   microdelay(200);
8665 
8666   return inb(CMOS_RETURN);
8667 }
8668 
8669 static void fill_rtcdate(struct rtcdate *r)
8670 {
8671   r->second = cmos_read(SECS);
8672   r->minute = cmos_read(MINS);
8673   r->hour   = cmos_read(HOURS);
8674   r->day    = cmos_read(DAY);
8675   r->month  = cmos_read(MONTH);
8676   r->year   = cmos_read(YEAR);
8677 }
8678 
8679 
8680 void cmostime(struct rtcdate *r)
8681 {
8682   struct rtcdate t1, t2;
8683   int sb, bcd;
8684 
8685   sb = cmos_read(CMOS_STATB);
8686 
8687   bcd = (sb & (1 << 2)) == 0;
8688 
8689   
8690   for(;;) {
8691     fill_rtcdate(&t1);
8692     if(cmos_read(CMOS_STATA) & CMOS_UIP)
8693         continue;
8694     fill_rtcdate(&t2);
8695     if(memcmp(&t1, &t2, sizeof(t1)) == 0)
8696       break;
8697   }
8698 
8699 
8700   
8701   if(bcd) {
8702 #define    CONV(x)     (t1.x = ((t1.x >> 4) * 10) + (t1.x & 0xf))
8703     CONV(second);
8704     CONV(minute);
8705     CONV(hour  );
8706     CONV(day   );
8707     CONV(month );
8708     CONV(year  );
8709 #undef     CONV
8710   }
8711 
8712   *r = t1;
8713   r->year += 2000;
8714 }
8715 
8716 
8717 
8718 
8719 
8720 
8721 
8722 
8723 
8724 
8725 
8726 
8727 
8728 
8729 
8730 
8731 
8732 
8733 
8734 
8735 
8736 
8737 
8738 
8739 
8740 
8741 
8742 
8743 
8744 
8745 
8746 
8747 
8748 
8749 
8750 
8751 
8752 
8753 
8754 #include "types.h"
8755 #include "defs.h"
8756 #include "traps.h"
8757 
8758 #define IOAPIC  0xFEC00000   
8759 
8760 #define REG_ID     0x00  
8761 #define REG_VER    0x01  
8762 #define REG_TABLE  0x10  
8763 
8764 
8765 
8766 
8767 
8768 
8769 #define INT_DISABLED   0x00010000  
8770 #define INT_LEVEL      0x00008000  
8771 #define INT_ACTIVELOW  0x00002000  
8772 #define INT_LOGICAL    0x00000800  
8773 
8774 volatile struct ioapic *ioapic;
8775 
8776 
8777 struct ioapic {
8778   uint reg;
8779   uint pad[3];
8780   uint data;
8781 };
8782 
8783 static uint
8784 ioapicread(int reg)
8785 {
8786   ioapic->reg = reg;
8787   return ioapic->data;
8788 }
8789 
8790 static void
8791 ioapicwrite(int reg, uint data)
8792 {
8793   ioapic->reg = reg;
8794   ioapic->data = data;
8795 }
8796 
8797 
8798 
8799 
8800 void
8801 ioapicinit(void)
8802 {
8803   int i, id, maxintr;
8804 
8805   if(!ismp)
8806     return;
8807 
8808   ioapic = (volatile struct ioapic*)IOAPIC;
8809   maxintr = (ioapicread(REG_VER) >> 16) & 0xFF;
8810   id = ioapicread(REG_ID) >> 24;
8811   if(id != ioapicid)
8812     cprintf("ioapicinit: id isn't equal to ioapicid; not a MP\n");
8813 
8814   
8815   
8816   for(i = 0; i <= maxintr; i++){
8817     ioapicwrite(REG_TABLE+2*i, INT_DISABLED | (T_IRQ0 + i));
8818     ioapicwrite(REG_TABLE+2*i+1, 0);
8819   }
8820 }
8821 
8822 void
8823 ioapicenable(int irq, int cpunum)
8824 {
8825   if(!ismp)
8826     return;
8827 
8828   
8829   
8830   
8831   ioapicwrite(REG_TABLE+2*irq, T_IRQ0 + irq);
8832   ioapicwrite(REG_TABLE+2*irq+1, cpunum << 24);
8833 }
8834 
8835 
8836 
8837 
8838 
8839 
8840 
8841 
8842 
8843 
8844 
8845 
8846 
8847 
8848 
8849 
8850 
8851 
8852 #include "types.h"
8853 #include "x86.h"
8854 #include "traps.h"
8855 
8856 
8857 #define IO_PIC1         0x20    
8858 #define IO_PIC2         0xA0    
8859 
8860 #define IRQ_SLAVE       2       
8861 
8862 
8863 
8864 static ushort irqmask = 0xFFFF & ~(1<<IRQ_SLAVE);
8865 
8866 static void
8867 picsetmask(ushort mask)
8868 {
8869   irqmask = mask;
8870   outb(IO_PIC1+1, mask);
8871   outb(IO_PIC2+1, mask >> 8);
8872 }
8873 
8874 void
8875 picenable(int irq)
8876 {
8877   picsetmask(irqmask & ~(1<<irq));
8878 }
8879 
8880 
8881 void
8882 picinit(void)
8883 {
8884   
8885   outb(IO_PIC1+1, 0xFF);
8886   outb(IO_PIC2+1, 0xFF);
8887 
8888   
8889 
8890   
8891   
8892   
8893   
8894   outb(IO_PIC1, 0x11);
8895 
8896   
8897   outb(IO_PIC1+1, T_IRQ0);
8898 
8899 
8900   
8901   
8902   outb(IO_PIC1+1, 1<<IRQ_SLAVE);
8903 
8904   
8905   
8906   
8907   
8908   
8909   
8910   
8911   
8912   outb(IO_PIC1+1, 0x3);
8913 
8914   
8915   outb(IO_PIC2, 0x11);                  
8916   outb(IO_PIC2+1, T_IRQ0 + 8);      
8917   outb(IO_PIC2+1, IRQ_SLAVE);           
8918   
8919   
8920   outb(IO_PIC2+1, 0x3);                 
8921 
8922   
8923   
8924   
8925   
8926   outb(IO_PIC1, 0x68);             
8927   outb(IO_PIC1, 0x0a);             
8928 
8929   outb(IO_PIC2, 0x68);             
8930   outb(IO_PIC2, 0x0a);             
8931 
8932   if(irqmask != 0xFFFF)
8933     picsetmask(irqmask);
8934 }
8935 
8936 
8937 
8938 
8939 
8940 
8941 
8942 
8943 
8944 
8945 
8946 
8947 
8948 
8949 
8950 
8951 
8952 
8953 
8954 
8955 
8956 
8957 
8958 
8959 
8960 
8961 
8962 
8963 
8964 
8965 
8966 
8967 
8968 
8969 
8970 
8971 
8972 
8973 
8974 
8975 
8976 
8977 
8978 
8979 
8980 
8981 
8982 
8983 
8984 
8985 
8986 
8987 
8988 
8989 
8990 
8991 
8992 
8993 
8994 
8995 
8996 
8997 
8998 
8999 
9000 
9001 
9002 #define KBSTATP         0x64    
9003 #define KBS_DIB         0x01    
9004 #define KBDATAP         0x60    
9005 
9006 #define NO              0
9007 
9008 #define SHIFT           (1<<0)
9009 #define CTL             (1<<1)
9010 #define ALT             (1<<2)
9011 
9012 #define CAPSLOCK        (1<<3)
9013 #define NUMLOCK         (1<<4)
9014 #define SCROLLLOCK      (1<<5)
9015 
9016 #define E0ESC           (1<<6)
9017 
9018 
9019 #define KEY_HOME        0xE0
9020 #define KEY_END         0xE1
9021 #define KEY_UP          0xE2
9022 #define KEY_DN          0xE3
9023 #define KEY_LF          0xE4
9024 #define KEY_RT          0xE5
9025 #define KEY_PGUP        0xE6
9026 #define KEY_PGDN        0xE7
9027 #define KEY_INS         0xE8
9028 #define KEY_DEL         0xE9
9029 
9030 
9031 #define C(x) (x - '@')
9032 
9033 static uchar shiftcode[256] =
9034 {
9035   [0x1D] CTL,
9036   [0x2A] SHIFT,
9037   [0x36] SHIFT,
9038   [0x38] ALT,
9039   [0x9D] CTL,
9040   [0xB8] ALT
9041 };
9042 
9043 static uchar togglecode[256] =
9044 {
9045   [0x3A] CAPSLOCK,
9046   [0x45] NUMLOCK,
9047   [0x46] SCROLLLOCK
9048 };
9049 
9050 static uchar normalmap[256] =
9051 {
9052   NO,   0x1B, '1',  '2',  '3',  '4',  '5',  '6',  
9053   '7',  '8',  '9',  '0',  '-',  '=',  '\b', '\t',
9054   'q',  'w',  'e',  'r',  't',  'y',  'u',  'i',  
9055   'o',  'p',  '[',  ']',  '\n', NO,   'a',  's',
9056   'd',  'f',  'g',  'h',  'j',  'k',  'l',  ';',  
9057   '\'', '`',  NO,   '\\', 'z',  'x',  'c',  'v',
9058   'b',  'n',  'm',  ',',  '.',  '/',  NO,   '*',  
9059   NO,   ' ',  NO,   NO,   NO,   NO,   NO,   NO,
9060   NO,   NO,   NO,   NO,   NO,   NO,   NO,   '7',  
9061   '8',  '9',  '-',  '4',  '5',  '6',  '+',  '1',
9062   '2',  '3',  '0',  '.',  NO,   NO,   NO,   NO,   
9063   [0x9C] '\n',      
9064   [0xB5] '/',       
9065   [0xC8] KEY_UP,    [0xD0] KEY_DN,
9066   [0xC9] KEY_PGUP,  [0xD1] KEY_PGDN,
9067   [0xCB] KEY_LF,    [0xCD] KEY_RT,
9068   [0x97] KEY_HOME,  [0xCF] KEY_END,
9069   [0xD2] KEY_INS,   [0xD3] KEY_DEL
9070 };
9071 
9072 static uchar shiftmap[256] =
9073 {
9074   NO,   033,  '!',  '@',  '#',  '$',  '%',  '^',  
9075   '&',  '*',  '(',  ')',  '_',  '+',  '\b', '\t',
9076   'Q',  'W',  'E',  'R',  'T',  'Y',  'U',  'I',  
9077   'O',  'P',  '{',  '}',  '\n', NO,   'A',  'S',
9078   'D',  'F',  'G',  'H',  'J',  'K',  'L',  ':',  
9079   '"',  '~',  NO,   '|',  'Z',  'X',  'C',  'V',
9080   'B',  'N',  'M',  '<',  '>',  '?',  NO,   '*',  
9081   NO,   ' ',  NO,   NO,   NO,   NO,   NO,   NO,
9082   NO,   NO,   NO,   NO,   NO,   NO,   NO,   '7',  
9083   '8',  '9',  '-',  '4',  '5',  '6',  '+',  '1',
9084   '2',  '3',  '0',  '.',  NO,   NO,   NO,   NO,   
9085   [0x9C] '\n',      
9086   [0xB5] '/',       
9087   [0xC8] KEY_UP,    [0xD0] KEY_DN,
9088   [0xC9] KEY_PGUP,  [0xD1] KEY_PGDN,
9089   [0xCB] KEY_LF,    [0xCD] KEY_RT,
9090   [0x97] KEY_HOME,  [0xCF] KEY_END,
9091   [0xD2] KEY_INS,   [0xD3] KEY_DEL
9092 };
9093 
9094 
9095 
9096 
9097 
9098 
9099 
9100 static uchar ctlmap[256] =
9101 {
9102   NO,      NO,      NO,      NO,      NO,      NO,      NO,      NO,
9103   NO,      NO,      NO,      NO,      NO,      NO,      NO,      NO,
9104   C('Q'),  C('W'),  C('E'),  C('R'),  C('T'),  C('Y'),  C('U'),  C('I'),
9105   C('O'),  C('P'),  NO,      NO,      '\r',    NO,      C('A'),  C('S'),
9106   C('D'),  C('F'),  C('G'),  C('H'),  C('J'),  C('K'),  C('L'),  NO,
9107   NO,      NO,      NO,      C('\\'), C('Z'),  C('X'),  C('C'),  C('V'),
9108   C('B'),  C('N'),  C('M'),  NO,      NO,      C('/'),  NO,      NO,
9109   [0x9C] '\r',      
9110   [0xB5] C('/'),    
9111   [0xC8] KEY_UP,    [0xD0] KEY_DN,
9112   [0xC9] KEY_PGUP,  [0xD1] KEY_PGDN,
9113   [0xCB] KEY_LF,    [0xCD] KEY_RT,
9114   [0x97] KEY_HOME,  [0xCF] KEY_END,
9115   [0xD2] KEY_INS,   [0xD3] KEY_DEL
9116 };
9117 
9118 
9119 
9120 
9121 
9122 
9123 
9124 
9125 
9126 
9127 
9128 
9129 
9130 
9131 
9132 
9133 
9134 
9135 
9136 
9137 
9138 
9139 
9140 
9141 
9142 
9143 
9144 
9145 
9146 
9147 
9148 
9149 
9150 #include "types.h"
9151 #include "x86.h"
9152 #include "defs.h"
9153 #include "kbd.h"
9154 
9155 int
9156 kbdgetc(void)
9157 {
9158   static uint shift;
9159   static uchar *charcode[4] = {
9160     normalmap, shiftmap, ctlmap, ctlmap
9161   };
9162   uint st, data, c;
9163 
9164   st = inb(KBSTATP);
9165   if((st & KBS_DIB) == 0)
9166     return -1;
9167   data = inb(KBDATAP);
9168 
9169   if(data == 0xE0){
9170     shift |= E0ESC;
9171     return 0;
9172   } else if(data & 0x80){
9173     
9174     data = (shift & E0ESC ? data : data & 0x7F);
9175     shift &= ~(shiftcode[data] | E0ESC);
9176     return 0;
9177   } else if(shift & E0ESC){
9178     
9179     data |= 0x80;
9180     shift &= ~E0ESC;
9181   }
9182 
9183   shift |= shiftcode[data];
9184   shift ^= togglecode[data];
9185   c = charcode[shift & (CTL | SHIFT)][data];
9186   if(shift & CAPSLOCK){
9187     if('a' <= c && c <= 'z')
9188       c += 'A' - 'a';
9189     else if('A' <= c && c <= 'Z')
9190       c += 'a' - 'A';
9191   }
9192   return c;
9193 }
9194 
9195 void
9196 kbdintr(void)
9197 {
9198   consoleintr(kbdgetc);
9199 }
9200 
9201 
9202 
9203 
9204 #include "types.h"
9205 #include "defs.h"
9206 #include "param.h"
9207 #include "traps.h"
9208 #include "spinlock.h"
9209 #include "sleeplock.h"
9210 #include "fs.h"
9211 #include "file.h"
9212 #include "memlayout.h"
9213 #include "mmu.h"
9214 #include "proc.h"
9215 #include "x86.h"
9216 
9217 static void consputc(int);
9218 
9219 static int panicked = 0;
9220 
9221 static struct {
9222   struct spinlock lock;
9223   int locking;
9224 } cons;
9225 
9226 static void
9227 printint(int xx, int base, int sign)
9228 {
9229   static char digits[] = "0123456789abcdef";
9230   char buf[16];
9231   int i;
9232   uint x;
9233 
9234   if(sign && (sign = xx < 0))
9235     x = -xx;
9236   else
9237     x = xx;
9238 
9239   i = 0;
9240   do{
9241     buf[i++] = digits[x % base];
9242   }while((x /= base) != 0);
9243 
9244   if(sign)
9245     buf[i++] = '-';
9246 
9247   while(--i >= 0)
9248     consputc(buf[i]);
9249 }
9250 
9251 
9252 
9253 
9254 
9255 
9256 
9257 
9258 
9259 
9260 
9261 
9262 
9263 
9264 
9265 
9266 
9267 
9268 
9269 
9270 
9271 
9272 
9273 
9274 
9275 
9276 
9277 
9278 
9279 
9280 
9281 
9282 
9283 
9284 
9285 
9286 
9287 
9288 
9289 
9290 
9291 
9292 
9293 
9294 
9295 
9296 
9297 
9298 
9299 
9300 
9301 void
9302 cprintf(char *fmt, ...)
9303 {
9304   int i, c, locking;
9305   uint *argp;
9306   char *s;
9307 
9308   locking = cons.locking;
9309   if(locking)
9310     acquire(&cons.lock);
9311 
9312   if (fmt == 0)
9313     panic("null fmt");
9314 
9315   argp = (uint*)(void*)(&fmt + 1);
9316   for(i = 0; (c = fmt[i] & 0xff) != 0; i++){
9317     if(c != '%'){
9318       consputc(c);
9319       continue;
9320     }
9321     c = fmt[++i] & 0xff;
9322     if(c == 0)
9323       break;
9324     switch(c){
9325     case 'd':
9326       printint(*argp++, 10, 1);
9327       break;
9328     case 'x':
9329     case 'p':
9330       printint(*argp++, 16, 0);
9331       break;
9332     case 's':
9333       if((s = (char*)*argp++) == 0)
9334         s = "(null)";
9335       for(; *s; s++)
9336         consputc(*s);
9337       break;
9338     case '%':
9339       consputc('%');
9340       break;
9341     default:
9342       
9343       consputc('%');
9344       consputc(c);
9345       break;
9346     }
9347   }
9348 
9349 
9350   if(locking)
9351     release(&cons.lock);
9352 }
9353 
9354 void
9355 panic(char *s)
9356 {
9357   int i;
9358   uint pcs[10];
9359 
9360   cli();
9361   cons.locking = 0;
9362   cprintf("cpu with apicid %d: panic: ", cpu->apicid);
9363   cprintf(s);
9364   cprintf("\n");
9365   getcallerpcs(&s, pcs);
9366   for(i=0; i<10; i++)
9367     cprintf(" %p", pcs[i]);
9368   panicked = 1; 
9369   for(;;)
9370     ;
9371 }
9372 
9373 
9374 
9375 
9376 
9377 
9378 
9379 
9380 
9381 
9382 
9383 
9384 
9385 
9386 
9387 
9388 
9389 
9390 
9391 
9392 
9393 
9394 
9395 
9396 
9397 
9398 
9399 
9400 #define BACKSPACE 0x100
9401 #define CRTPORT 0x3d4
9402 static ushort *crt = (ushort*)P2V(0xb8000);  
9403 
9404 static void
9405 cgaputc(int c)
9406 {
9407   int pos;
9408 
9409   
9410   outb(CRTPORT, 14);
9411   pos = inb(CRTPORT+1) << 8;
9412   outb(CRTPORT, 15);
9413   pos |= inb(CRTPORT+1);
9414 
9415   if(c == '\n')
9416     pos += 80 - pos%80;
9417   else if(c == BACKSPACE){
9418     if(pos > 0) --pos;
9419   } else
9420     crt[pos++] = (c&0xff) | 0x0700;  
9421 
9422   if(pos < 0 || pos > 25*80)
9423     panic("pos under/overflow");
9424 
9425   if((pos/80) >= 24){  
9426     memmove(crt, crt+80, sizeof(crt[0])*23*80);
9427     pos -= 80;
9428     memset(crt+pos, 0, sizeof(crt[0])*(24*80 - pos));
9429   }
9430 
9431   outb(CRTPORT, 14);
9432   outb(CRTPORT+1, pos>>8);
9433   outb(CRTPORT, 15);
9434   outb(CRTPORT+1, pos);
9435   crt[pos] = ' ' | 0x0700;
9436 }
9437 
9438 
9439 
9440 
9441 
9442 
9443 
9444 
9445 
9446 
9447 
9448 
9449 
9450 void
9451 consputc(int c)
9452 {
9453   if(panicked){
9454     cli();
9455     for(;;)
9456       ;
9457   }
9458 
9459   if(c == BACKSPACE){
9460     uartputc('\b'); uartputc(' '); uartputc('\b');
9461   } else
9462     uartputc(c);
9463   cgaputc(c);
9464 }
9465 
9466 #define INPUT_BUF 128
9467 struct {
9468   char buf[INPUT_BUF];
9469   uint r;  
9470   uint w;  
9471   uint e;  
9472 } input;
9473 
9474 #define C(x)  ((x)-'@')  
9475 
9476 void
9477 consoleintr(int (*getc)(void))
9478 {
9479   int c, doprocdump = 0;
9480 
9481   acquire(&cons.lock);
9482   while((c = getc()) >= 0){
9483     switch(c){
9484     case C('P'):  
9485       
9486       doprocdump = 1;
9487       break;
9488     case C('U'):  
9489       while(input.e != input.w &&
9490             input.buf[(input.e-1) % INPUT_BUF] != '\n'){
9491         input.e--;
9492         consputc(BACKSPACE);
9493       }
9494       break;
9495     case C('H'): case '\x7f':  
9496       if(input.e != input.w){
9497         input.e--;
9498         consputc(BACKSPACE);
9499       }
9500       break;
9501     default:
9502       if(c != 0 && input.e-input.r < INPUT_BUF){
9503         c = (c == '\r') ? '\n' : c;
9504         input.buf[input.e++ % INPUT_BUF] = c;
9505         consputc(c);
9506         if(c == '\n' || c == C('D') || input.e == input.r+INPUT_BUF){
9507           input.w = input.e;
9508           wakeup(&input.r);
9509         }
9510       }
9511       break;
9512     }
9513   }
9514   release(&cons.lock);
9515   if(doprocdump) {
9516     procdump();  
9517   }
9518 }
9519 
9520 int
9521 consoleread(struct inode *ip, char *dst, int n)
9522 {
9523   uint target;
9524   int c;
9525 
9526   iunlock(ip);
9527   target = n;
9528   acquire(&cons.lock);
9529   while(n > 0){
9530     while(input.r == input.w){
9531       if(proc->killed){
9532         release(&cons.lock);
9533         ilock(ip);
9534         return -1;
9535       }
9536       sleep(&input.r, &cons.lock);
9537     }
9538     c = input.buf[input.r++ % INPUT_BUF];
9539     if(c == C('D')){  
9540       if(n < target){
9541         
9542         
9543         input.r--;
9544       }
9545       break;
9546     }
9547     *dst++ = c;
9548     --n;
9549     if(c == '\n')
9550       break;
9551   }
9552   release(&cons.lock);
9553   ilock(ip);
9554 
9555   return target - n;
9556 }
9557 
9558 int
9559 consolewrite(struct inode *ip, char *buf, int n)
9560 {
9561   int i;
9562 
9563   iunlock(ip);
9564   acquire(&cons.lock);
9565   for(i = 0; i < n; i++)
9566     consputc(buf[i] & 0xff);
9567   release(&cons.lock);
9568   ilock(ip);
9569 
9570   return n;
9571 }
9572 
9573 void
9574 consoleinit(void)
9575 {
9576   initlock(&cons.lock, "console");
9577 
9578   devsw[CONSOLE].write = consolewrite;
9579   devsw[CONSOLE].read = consoleread;
9580   cons.locking = 1;
9581 
9582   picenable(IRQ_KBD);
9583   ioapicenable(IRQ_KBD, 0);
9584 }
9585 
9586 
9587 
9588 
9589 
9590 
9591 
9592 
9593 
9594 
9595 
9596 
9597 
9598 
9599 
9600 
9601 
9602 
9603 
9604 #include "types.h"
9605 #include "defs.h"
9606 #include "traps.h"
9607 #include "x86.h"
9608 
9609 #define IO_TIMER1       0x040           
9610 
9611 
9612 
9613 
9614 
9615 #define TIMER_FREQ      1193182
9616 #define TIMER_DIV(x)    ((TIMER_FREQ+(x)/2)/(x))
9617 
9618 #define TIMER_MODE      (IO_TIMER1 + 3) 
9619 #define TIMER_SEL0      0x00    
9620 #define TIMER_RATEGEN   0x04    
9621 #define TIMER_16BIT     0x30    
9622 
9623 void
9624 timerinit(void)
9625 {
9626   
9627   outb(TIMER_MODE, TIMER_SEL0 | TIMER_RATEGEN | TIMER_16BIT);
9628   outb(IO_TIMER1, TIMER_DIV(100) % 256);
9629   outb(IO_TIMER1, TIMER_DIV(100) / 256);
9630   picenable(IRQ_TIMER);
9631 }
9632 
9633 
9634 
9635 
9636 
9637 
9638 
9639 
9640 
9641 
9642 
9643 
9644 
9645 
9646 
9647 
9648 
9649 
9650 
9651 
9652 #include "types.h"
9653 #include "defs.h"
9654 #include "param.h"
9655 #include "traps.h"
9656 #include "spinlock.h"
9657 #include "sleeplock.h"
9658 #include "fs.h"
9659 #include "file.h"
9660 #include "mmu.h"
9661 #include "proc.h"
9662 #include "x86.h"
9663 
9664 #define COM1    0x3f8
9665 
9666 static int uart;    
9667 
9668 void
9669 uartinit(void)
9670 {
9671   char *p;
9672 
9673   
9674   outb(COM1+2, 0);
9675 
9676   
9677   outb(COM1+3, 0x80);    
9678   outb(COM1+0, 115200/9600);
9679   outb(COM1+1, 0);
9680   outb(COM1+3, 0x03);    
9681   outb(COM1+4, 0);
9682   outb(COM1+1, 0x01);    
9683 
9684   
9685   if(inb(COM1+5) == 0xFF)
9686     return;
9687   uart = 1;
9688 
9689   
9690   
9691   inb(COM1+2);
9692   inb(COM1+0);
9693   picenable(IRQ_COM1);
9694   ioapicenable(IRQ_COM1, 0);
9695 
9696   
9697   for(p="xv6...\n"; *p; p++)
9698     uartputc(*p);
9699 }
9700 void
9701 uartputc(int c)
9702 {
9703   int i;
9704 
9705   if(!uart)
9706     return;
9707   for(i = 0; i < 128 && !(inb(COM1+5) & 0x20); i++)
9708     microdelay(10);
9709   outb(COM1+0, c);
9710 }
9711 
9712 static int
9713 uartgetc(void)
9714 {
9715   if(!uart)
9716     return -1;
9717   if(!(inb(COM1+5) & 0x01))
9718     return -1;
9719   return inb(COM1+0);
9720 }
9721 
9722 void
9723 uartintr(void)
9724 {
9725   consoleintr(uartgetc);
9726 }
9727 
9728 
9729 
9730 
9731 
9732 
9733 
9734 
9735 
9736 
9737 
9738 
9739 
9740 
9741 
9742 
9743 
9744 
9745 
9746 
9747 
9748 
9749 
9750 
9751 
9752 
9753 
9754 
9755 
9756 
9757 
9758 .globl start
9759 start:
9760   pushl $argv
9761   pushl $init
9762   pushl $0  
9763   movl $SYS_exec, %eax
9764   int $T_SYSCALL
9765 
9766 
9767 exit:
9768   movl $SYS_exit, %eax
9769   int $T_SYSCALL
9770   jmp exit
9771 
9772 
9773 init:
9774   .string "/init\0"
9775 
9776 
9777 .p2align 2
9778 argv:
9779   .long init
9780   .long 0
9781 
9782 
9783 
9784 
9785 
9786 
9787 
9788 
9789 
9790 
9791 
9792 
9793 
9794 
9795 
9796 
9797 
9798 
9799 
9800 
9801 
9802 
9803 
9804   .globl name; \
9805   name: \
9806     movl $SYS_ 
9807     int $T_SYSCALL; \
9808     ret
9809 
9810 SYSCALL(fork)
9811 SYSCALL(exit)
9812 SYSCALL(wait)
9813 SYSCALL(pipe)
9814 SYSCALL(read)
9815 SYSCALL(write)
9816 SYSCALL(close)
9817 SYSCALL(kill)
9818 SYSCALL(exec)
9819 SYSCALL(open)
9820 SYSCALL(mknod)
9821 SYSCALL(unlink)
9822 SYSCALL(fstat)
9823 SYSCALL(link)
9824 SYSCALL(mkdir)
9825 SYSCALL(chdir)
9826 SYSCALL(dup)
9827 SYSCALL(getpid)
9828 SYSCALL(getppid)
9829 SYSCALL(sbrk)
9830 SYSCALL(sleep)
9831 SYSCALL(uptime)
9832 SYSCALL(my_syscall)
9833 SYSCALL(yield)
9834 SYSCALL(getlev)
9835 SYSCALL(set_cpu_share)
9836 SYSCALL(thread_create)
9837 SYSCALL(thread_exit)
9838 SYSCALL(thread_join)
9839 
9840 
9841 
9842 
9843 
9844 
9845 
9846 
9847 
9848 
9849 
9850 
9851 
9852 #include "types.h"
9853 #include "stat.h"
9854 #include "user.h"
9855 #include "fcntl.h"
9856 
9857 char *argv[] = { "sh", 0 };
9858 
9859 int
9860 main(void)
9861 {
9862   int pid, wpid;
9863 
9864   if(open("console", O_RDWR) < 0){
9865     mknod("console", 1, 1);
9866     open("console", O_RDWR);
9867   }
9868   dup(0);  
9869   dup(0);  
9870 
9871   for(;;){
9872     printf(1, "init: starting sh\n");
9873     pid = fork();
9874     if(pid < 0){
9875       printf(1, "init: fork failed\n");
9876       exit();
9877     }
9878     if(pid == 0){
9879       exec("sh", argv);
9880       printf(1, "init: exec sh failed\n");
9881       exit();
9882     }
9883     while((wpid=wait()) >= 0 && wpid != pid)
9884       printf(1, "zombie!\n");
9885   }
9886 }
9887 
9888 
9889 
9890 
9891 
9892 
9893 
9894 
9895 
9896 
9897 
9898 
9899 
9900 
9901 
9902 #include "types.h"
9903 #include "user.h"
9904 #include "fcntl.h"
9905 
9906 
9907 #define EXEC  1
9908 #define REDIR 2
9909 #define PIPE  3
9910 #define LIST  4
9911 #define BACK  5
9912 
9913 #define MAXARGS 10
9914 
9915 struct cmd {
9916   int type;
9917 };
9918 
9919 struct execcmd {
9920   int type;
9921   char *argv[MAXARGS];
9922   char *eargv[MAXARGS];
9923 };
9924 
9925 struct redircmd {
9926   int type;
9927   struct cmd *cmd;
9928   char *file;
9929   char *efile;
9930   int mode;
9931   int fd;
9932 };
9933 
9934 struct pipecmd {
9935   int type;
9936   struct cmd *left;
9937   struct cmd *right;
9938 };
9939 
9940 struct listcmd {
9941   int type;
9942   struct cmd *left;
9943   struct cmd *right;
9944 };
9945 
9946 struct backcmd {
9947   int type;
9948   struct cmd *cmd;
9949 };
9950 int fork1(void);  
9951 void panic(char*);
9952 struct cmd *parsecmd(char*);
9953 
9954 
9955 void
9956 runcmd(struct cmd *cmd)
9957 {
9958   int p[2];
9959   struct backcmd *bcmd;
9960   struct execcmd *ecmd;
9961   struct listcmd *lcmd;
9962   struct pipecmd *pcmd;
9963   struct redircmd *rcmd;
9964 
9965   if(cmd == 0)
9966     exit();
9967 
9968   switch(cmd->type){
9969   default:
9970     panic("runcmd");
9971 
9972   case EXEC:
9973     ecmd = (struct execcmd*)cmd;
9974     if(ecmd->argv[0] == 0)
9975       exit();
9976     exec(ecmd->argv[0], ecmd->argv);
9977     printf(2, "exec %s failed\n", ecmd->argv[0]);
9978     break;
9979 
9980   case REDIR:
9981     rcmd = (struct redircmd*)cmd;
9982     close(rcmd->fd);
9983     if(open(rcmd->file, rcmd->mode) < 0){
9984       printf(2, "open %s failed\n", rcmd->file);
9985       exit();
9986     }
9987     runcmd(rcmd->cmd);
9988     break;
9989 
9990   case LIST:
9991     lcmd = (struct listcmd*)cmd;
9992     if(fork1() == 0)
9993       runcmd(lcmd->left);
9994     wait();
9995     runcmd(lcmd->right);
9996     break;
9997 
9998 
9999 
10000   case PIPE:
10001     pcmd = (struct pipecmd*)cmd;
10002     if(pipe(p) < 0)
10003       panic("pipe");
10004     if(fork1() == 0){
10005       close(1);
10006       dup(p[1]);
10007       close(p[0]);
10008       close(p[1]);
10009       runcmd(pcmd->left);
10010     }
10011     if(fork1() == 0){
10012       close(0);
10013       dup(p[0]);
10014       close(p[0]);
10015       close(p[1]);
10016       runcmd(pcmd->right);
10017     }
10018     close(p[0]);
10019     close(p[1]);
10020     wait();
10021     wait();
10022     break;
10023 
10024   case BACK:
10025     bcmd = (struct backcmd*)cmd;
10026     if(fork1() == 0)
10027       runcmd(bcmd->cmd);
10028     break;
10029   }
10030   exit();
10031 }
10032 
10033 int
10034 getcmd(char *buf, int nbuf)
10035 {
10036   printf(2, "$ ");
10037   memset(buf, 0, nbuf);
10038   gets(buf, nbuf);
10039   if(buf[0] == 0) 
10040     return -1;
10041   return 0;
10042 }
10043 
10044 
10045 
10046 
10047 
10048 
10049 
10050 int
10051 main(void)
10052 {
10053   static char buf[100];
10054   int fd;
10055 
10056   
10057   while((fd = open("console", O_RDWR)) >= 0){
10058     if(fd >= 3){
10059       close(fd);
10060       break;
10061     }
10062   }
10063 
10064   
10065   while(getcmd(buf, sizeof(buf)) >= 0){
10066     if(buf[0] == 'c' && buf[1] == 'd' && buf[2] == ' '){
10067       
10068       buf[strlen(buf)-1] = 0;  
10069       if(chdir(buf+3) < 0)
10070         printf(2, "cannot cd %s\n", buf+3);
10071       continue;
10072     }
10073     if(fork1() == 0)
10074       runcmd(parsecmd(buf));
10075     wait();
10076   }
10077   exit();
10078 }
10079 
10080 void
10081 panic(char *s)
10082 {
10083   printf(2, "%s\n", s);
10084   exit();
10085 }
10086 
10087 int
10088 fork1(void)
10089 {
10090   int pid;
10091 
10092   pid = fork();
10093   if(pid == -1)
10094     panic("fork");
10095   return pid;
10096 }
10097 
10098 
10099 
10100 
10101 
10102 struct cmd*
10103 execcmd(void)
10104 {
10105   struct execcmd *cmd;
10106 
10107   cmd = malloc(sizeof(*cmd));
10108   memset(cmd, 0, sizeof(*cmd));
10109   cmd->type = EXEC;
10110   return (struct cmd*)cmd;
10111 }
10112 
10113 struct cmd*
10114 redircmd(struct cmd *subcmd, char *file, char *efile, int mode, int fd)
10115 {
10116   struct redircmd *cmd;
10117 
10118   cmd = malloc(sizeof(*cmd));
10119   memset(cmd, 0, sizeof(*cmd));
10120   cmd->type = REDIR;
10121   cmd->cmd = subcmd;
10122   cmd->file = file;
10123   cmd->efile = efile;
10124   cmd->mode = mode;
10125   cmd->fd = fd;
10126   return (struct cmd*)cmd;
10127 }
10128 
10129 struct cmd*
10130 pipecmd(struct cmd *left, struct cmd *right)
10131 {
10132   struct pipecmd *cmd;
10133 
10134   cmd = malloc(sizeof(*cmd));
10135   memset(cmd, 0, sizeof(*cmd));
10136   cmd->type = PIPE;
10137   cmd->left = left;
10138   cmd->right = right;
10139   return (struct cmd*)cmd;
10140 }
10141 
10142 
10143 
10144 
10145 
10146 
10147 
10148 
10149 
10150 struct cmd*
10151 listcmd(struct cmd *left, struct cmd *right)
10152 {
10153   struct listcmd *cmd;
10154 
10155   cmd = malloc(sizeof(*cmd));
10156   memset(cmd, 0, sizeof(*cmd));
10157   cmd->type = LIST;
10158   cmd->left = left;
10159   cmd->right = right;
10160   return (struct cmd*)cmd;
10161 }
10162 
10163 struct cmd*
10164 backcmd(struct cmd *subcmd)
10165 {
10166   struct backcmd *cmd;
10167 
10168   cmd = malloc(sizeof(*cmd));
10169   memset(cmd, 0, sizeof(*cmd));
10170   cmd->type = BACK;
10171   cmd->cmd = subcmd;
10172   return (struct cmd*)cmd;
10173 }
10174 
10175 
10176 
10177 
10178 
10179 
10180 
10181 
10182 
10183 
10184 
10185 
10186 
10187 
10188 
10189 
10190 
10191 
10192 
10193 
10194 
10195 
10196 
10197 
10198 
10199 
10200 
10201 
10202 char whitespace[] = " \t\r\n\v";
10203 char symbols[] = "<|>&;()";
10204 
10205 int
10206 gettoken(char **ps, char *es, char **q, char **eq)
10207 {
10208   char *s;
10209   int ret;
10210 
10211   s = *ps;
10212   while(s < es && strchr(whitespace, *s))
10213     s++;
10214   if(q)
10215     *q = s;
10216   ret = *s;
10217   switch(*s){
10218   case 0:
10219     break;
10220   case '|':
10221   case '(':
10222   case ')':
10223   case ';':
10224   case '&':
10225   case '<':
10226     s++;
10227     break;
10228   case '>':
10229     s++;
10230     if(*s == '>'){
10231       ret = '+';
10232       s++;
10233     }
10234     break;
10235   default:
10236     ret = 'a';
10237     while(s < es && !strchr(whitespace, *s) && !strchr(symbols, *s))
10238       s++;
10239     break;
10240   }
10241   if(eq)
10242     *eq = s;
10243 
10244   while(s < es && strchr(whitespace, *s))
10245     s++;
10246   *ps = s;
10247   return ret;
10248 }
10249 
10250 int
10251 peek(char **ps, char *es, char *toks)
10252 {
10253   char *s;
10254 
10255   s = *ps;
10256   while(s < es && strchr(whitespace, *s))
10257     s++;
10258   *ps = s;
10259   return *s && strchr(toks, *s);
10260 }
10261 
10262 struct cmd *parseline(char**, char*);
10263 struct cmd *parsepipe(char**, char*);
10264 struct cmd *parseexec(char**, char*);
10265 struct cmd *nulterminate(struct cmd*);
10266 
10267 struct cmd*
10268 parsecmd(char *s)
10269 {
10270   char *es;
10271   struct cmd *cmd;
10272 
10273   es = s + strlen(s);
10274   cmd = parseline(&s, es);
10275   peek(&s, es, "");
10276   if(s != es){
10277     printf(2, "leftovers: %s\n", s);
10278     panic("syntax");
10279   }
10280   nulterminate(cmd);
10281   return cmd;
10282 }
10283 
10284 struct cmd*
10285 parseline(char **ps, char *es)
10286 {
10287   struct cmd *cmd;
10288 
10289   cmd = parsepipe(ps, es);
10290   while(peek(ps, es, "&")){
10291     gettoken(ps, es, 0, 0);
10292     cmd = backcmd(cmd);
10293   }
10294   if(peek(ps, es, ";")){
10295     gettoken(ps, es, 0, 0);
10296     cmd = listcmd(cmd, parseline(ps, es));
10297   }
10298   return cmd;
10299 }
10300 struct cmd*
10301 parsepipe(char **ps, char *es)
10302 {
10303   struct cmd *cmd;
10304 
10305   cmd = parseexec(ps, es);
10306   if(peek(ps, es, "|")){
10307     gettoken(ps, es, 0, 0);
10308     cmd = pipecmd(cmd, parsepipe(ps, es));
10309   }
10310   return cmd;
10311 }
10312 
10313 struct cmd*
10314 parseredirs(struct cmd *cmd, char **ps, char *es)
10315 {
10316   int tok;
10317   char *q, *eq;
10318 
10319   while(peek(ps, es, "<>")){
10320     tok = gettoken(ps, es, 0, 0);
10321     if(gettoken(ps, es, &q, &eq) != 'a')
10322       panic("missing file for redirection");
10323     switch(tok){
10324     case '<':
10325       cmd = redircmd(cmd, q, eq, O_RDONLY, 0);
10326       break;
10327     case '>':
10328       cmd = redircmd(cmd, q, eq, O_WRONLY|O_CREATE, 1);
10329       break;
10330     case '+':  
10331       cmd = redircmd(cmd, q, eq, O_WRONLY|O_CREATE, 1);
10332       break;
10333     }
10334   }
10335   return cmd;
10336 }
10337 
10338 
10339 
10340 
10341 
10342 
10343 
10344 
10345 
10346 
10347 
10348 
10349 
10350 struct cmd*
10351 parseblock(char **ps, char *es)
10352 {
10353   struct cmd *cmd;
10354 
10355   if(!peek(ps, es, "("))
10356     panic("parseblock");
10357   gettoken(ps, es, 0, 0);
10358   cmd = parseline(ps, es);
10359   if(!peek(ps, es, ")"))
10360     panic("syntax - missing )");
10361   gettoken(ps, es, 0, 0);
10362   cmd = parseredirs(cmd, ps, es);
10363   return cmd;
10364 }
10365 
10366 struct cmd*
10367 parseexec(char **ps, char *es)
10368 {
10369   char *q, *eq;
10370   int tok, argc;
10371   struct execcmd *cmd;
10372   struct cmd *ret;
10373 
10374   if(peek(ps, es, "("))
10375     return parseblock(ps, es);
10376 
10377   ret = execcmd();
10378   cmd = (struct execcmd*)ret;
10379 
10380   argc = 0;
10381   ret = parseredirs(ret, ps, es);
10382   while(!peek(ps, es, "|)&;")){
10383     if((tok=gettoken(ps, es, &q, &eq)) == 0)
10384       break;
10385     if(tok != 'a')
10386       panic("syntax");
10387     cmd->argv[argc] = q;
10388     cmd->eargv[argc] = eq;
10389     argc++;
10390     if(argc >= MAXARGS)
10391       panic("too many args");
10392     ret = parseredirs(ret, ps, es);
10393   }
10394   cmd->argv[argc] = 0;
10395   cmd->eargv[argc] = 0;
10396   return ret;
10397 }
10398 
10399 
10400 
10401 struct cmd*
10402 nulterminate(struct cmd *cmd)
10403 {
10404   int i;
10405   struct backcmd *bcmd;
10406   struct execcmd *ecmd;
10407   struct listcmd *lcmd;
10408   struct pipecmd *pcmd;
10409   struct redircmd *rcmd;
10410 
10411   if(cmd == 0)
10412     return 0;
10413 
10414   switch(cmd->type){
10415   case EXEC:
10416     ecmd = (struct execcmd*)cmd;
10417     for(i=0; ecmd->argv[i]; i++)
10418       *ecmd->eargv[i] = 0;
10419     break;
10420 
10421   case REDIR:
10422     rcmd = (struct redircmd*)cmd;
10423     nulterminate(rcmd->cmd);
10424     *rcmd->efile = 0;
10425     break;
10426 
10427   case PIPE:
10428     pcmd = (struct pipecmd*)cmd;
10429     nulterminate(pcmd->left);
10430     nulterminate(pcmd->right);
10431     break;
10432 
10433   case LIST:
10434     lcmd = (struct listcmd*)cmd;
10435     nulterminate(lcmd->left);
10436     nulterminate(lcmd->right);
10437     break;
10438 
10439   case BACK:
10440     bcmd = (struct backcmd*)cmd;
10441     nulterminate(bcmd->cmd);
10442     break;
10443   }
10444   return cmd;
10445 }
10446 
10447 
10448 
10449 
10450 
10451 
10452 
10453 
10454 
10455 
10456 
10457 
10458 
10459 .code16                       
10460 .globl start
10461 start:
10462   cli                         
10463 
10464   
10465   xorw    %ax,%ax             
10466   movw    %ax,%ds             
10467   movw    %ax,%es             
10468   movw    %ax,%ss             
10469 
10470   
10471   
10472 seta20.1:
10473   inb     $0x64,%al               
10474   testb   $0x2,%al
10475   jnz     seta20.1
10476 
10477   movb    $0xd1,%al               
10478   outb    %al,$0x64
10479 
10480 seta20.2:
10481   inb     $0x64,%al               
10482   testb   $0x2,%al
10483   jnz     seta20.2
10484 
10485   movb    $0xdf,%al               
10486   outb    %al,$0x60
10487 
10488   
10489   
10490   
10491   lgdt    gdtdesc
10492   movl    %cr0, %eax
10493   orl     $CR0_PE, %eax
10494   movl    %eax, %cr0
10495 
10496 
10497 
10498 
10499 
10500   
10501   
10502   
10503   ljmp    $(SEG_KCODE<<3), $start32
10504 
10505 .code32  
10506 start32:
10507   
10508   movw    $(SEG_KDATA<<3), %ax    
10509   movw    %ax, %ds                
10510   movw    %ax, %es                
10511   movw    %ax, %ss                
10512   movw    $0, %ax                 
10513   movw    %ax, %fs                
10514   movw    %ax, %gs                
10515 
10516   
10517   movl    $start, %esp
10518   call    bootmain
10519 
10520   
10521   
10522   movw    $0x8a00, %ax            
10523   movw    %ax, %dx
10524   outw    %ax, %dx
10525   movw    $0x8ae0, %ax            
10526   outw    %ax, %dx
10527 spin:
10528   jmp     spin
10529 
10530 
10531 .p2align 2                                
10532 gdt:
10533   SEG_NULLASM                             
10534   SEG_ASM(STA_X|STA_R, 0x0, 0xffffffff)   
10535   SEG_ASM(STA_W, 0x0, 0xffffffff)         
10536 
10537 gdtdesc:
10538   .word   (gdtdesc - gdt - 1)             
10539   .long   gdt                             
10540 
10541 
10542 
10543 
10544 
10545 
10546 
10547 
10548 
10549 
10550 
10551 
10552 
10553 
10554 
10555 
10556 
10557 #include "types.h"
10558 #include "elf.h"
10559 #include "x86.h"
10560 #include "memlayout.h"
10561 
10562 #define SECTSIZE  512
10563 
10564 void readseg(uchar*, uint, uint);
10565 
10566 void
10567 bootmain(void)
10568 {
10569   struct elfhdr *elf;
10570   struct proghdr *ph, *eph;
10571   void (*entry)(void);
10572   uchar* pa;
10573 
10574   elf = (struct elfhdr*)0x10000;  
10575 
10576   
10577   readseg((uchar*)elf, 4096, 0);
10578 
10579   
10580   if(elf->magic != ELF_MAGIC)
10581     return;  
10582 
10583   
10584   ph = (struct proghdr*)((uchar*)elf + elf->phoff);
10585   eph = ph + elf->phnum;
10586   for(; ph < eph; ph++){
10587     pa = (uchar*)ph->paddr;
10588     readseg(pa, ph->filesz, ph->off);
10589     if(ph->memsz > ph->filesz)
10590       stosb(pa + ph->filesz, 0, ph->memsz - ph->filesz);
10591   }
10592 
10593   
10594   
10595   entry = (void(*)(void))(elf->entry);
10596   entry();
10597 }
10598 
10599 
10600 void
10601 waitdisk(void)
10602 {
10603   
10604   while((inb(0x1F7) & 0xC0) != 0x40)
10605     ;
10606 }
10607 
10608 
10609 void
10610 readsect(void *dst, uint offset)
10611 {
10612   
10613   waitdisk();
10614   outb(0x1F2, 1);   
10615   outb(0x1F3, offset);
10616   outb(0x1F4, offset >> 8);
10617   outb(0x1F5, offset >> 16);
10618   outb(0x1F6, (offset >> 24) | 0xE0);
10619   outb(0x1F7, 0x20);  
10620 
10621   
10622   waitdisk();
10623   insl(0x1F0, dst, SECTSIZE/4);
10624 }
10625 
10626 
10627 
10628 void
10629 readseg(uchar* pa, uint count, uint offset)
10630 {
10631   uchar* epa;
10632 
10633   epa = pa + count;
10634 
10635   
10636   pa -= offset % SECTSIZE;
10637 
10638   
10639   offset = (offset / SECTSIZE) + 1;
10640 
10641   
10642   
10643   
10644   for(; pa < epa; pa += SECTSIZE, offset++)
10645     readsect(pa, offset);
10646 }
10647 
10648 
10649 
